{"version":3,"sources":["lib/edit/methods.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","CodeMirror","optionHandlers","helpers","prototype","constructor","focus","window","this","display","input","setOption","option","value","options","old","hasOwnProperty","operation","signal","getOption","getDoc","doc","addKeyMap","map","bottom","state","keyMaps","getKeyMap","removeKeyMap","maps","length","name","splice","addOverlay","methodOp","spec","mode","token","getMode","startState","Error","insertSorted","overlays","modeSpec","opaque","priority","overlay","modeGen","regChange","removeOverlay","cur","indentLine","dir","aggressive","smartIndent","isLine","indentSelection","how","ranges","sel","end","range","empty","head","line","primIndex","ensureCursorVisible","from","to","start","Math","max","min","lastLine","ch","newRanges","replaceOneSelection","Range","sel_dontScroll","getTokenAt","pos","precise","takeToken","getLineTokens","Pos","getTokenTypeAt","clipPos","type","styles","getLineStyles","getLine","before","after","mid","cut","undefined","slice","getModeAt","innerMode","getHelper","getHelpers","found","help","push","val","helperType","_global","pred","indexOf","getStateAfter","clipLine","first","size","getContextBefore","cursorCoords","primary","charCoords","coordsChar","coords","fromCoordSystem","left","top","lineAtHeight","height","viewOffset","heightAtLine","includeWidgets","lineObj","last","intoCoordSystem","defaultTextHeight","textHeight","defaultCharWidth","charWidth","getViewport","viewFrom","viewTo","addWidget","node","scroll","vert","horiz","style","position","setAttribute","setUneditable","sizer","appendChild","vspace","wrapper","clientHeight","hspace","clientWidth","lineSpace","offsetHeight","offsetWidth","right","scrollIntoView","triggerOnKeyDown","onKeyDown","triggerOnKeyPress","onKeyPress","triggerOnKeyUp","onKeyUp","triggerOnMouseDown","onMouseDown","execCommand","cmd","commands","call","triggerElectric","text","findPosH","amount","unit","visually","hitSide","moveH","extendSelectionsBy","shift","extend","rtlMoveVisually","sel_move","deleteH","somethingSelected","replaceSelection","deleteNearSelection","other","findPosV","goalColumn","moveV","goals","collapse","headPos","addToScrollTop","findWordAt","helper","sticky","startChar","charAt","check","isWordChar","test","toggleOverwrite","overwrite","addClass","cursorDiv","rmClass","hasFocus","getField","activeElt","isReadOnly","readOnly","cantEdit","scrollTo","y","scrollToCoords","getScrollInfo","scroller","scrollLeft","scrollTop","scrollHeight","scrollGap","barHeight","width","scrollWidth","barWidth","displayHeight","displayWidth","margin","cursorScrollMargin","scrollToRange","scrollToCoordsRange","setSize","interpret","String","lineWrapping","clearLineMeasurementCache","lineNo","iter","widgets","noHScroll","regLineChange","curOp","forceUpdate","runInOp","startOperation","endOperation","refresh","oldHeight","cachedTextHeight","clearCaches","updateGutterSpace","abs","estimateLineHeights","swapDoc","cm","attachDoc","reset","forceScroll","signalLater","phrase","phraseText","phrases","Object","getInputField","getWrapperElement","getScrollerElement","getGutterElement","gutters","eventMixin","registerHelper","registerGlobalHelper","predicate","oldPos","origDir","moveOnce","boundToLine","next","moveVisually","moveLogically","findNextLine","endOfLine","sawType","group","result","skipAtomic","equalCursorPos","target","pageSize","innerHeight","document","documentElement","moveAmount","outside"],"mappings":"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","file":"../../../lib/edit/methods.js","sourcesContent":["define([\n    './deleteNearSelection',\n    './commands',\n    '../model/document_data',\n    '../util/dom',\n    '../util/event',\n    '../line/highlight',\n    '../input/indent',\n    '../input/input',\n    './key_events',\n    './mouse_events',\n    '../input/keymap',\n    '../input/movement',\n    '../display/operations',\n    '../line/pos',\n    '../measurement/position_measurement',\n    '../model/selection',\n    '../model/selection_updates',\n    '../display/scrolling',\n    '../line/spans',\n    '../display/update_display',\n    '../util/misc',\n    '../util/operation_group',\n    '../line/utils_line',\n    '../display/view_tracking'\n], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x) {\n    'use strict';\n    return function (CodeMirror) {\n        let optionHandlers = CodeMirror.optionHandlers;\n        let helpers = CodeMirror.helpers = {};\n        CodeMirror.prototype = {\n            constructor: CodeMirror,\n            focus: function () {\n                window.focus();\n                this.display.input.focus();\n            },\n            setOption: function (option, value) {\n                let options = this.options, old = options[option];\n                if (options[option] == value && option != 'mode')\n                    return;\n                options[option] = value;\n                if (optionHandlers.hasOwnProperty(option))\n                    m.operation(this, optionHandlers[option])(this, value, old);\n                e.signal(this, 'optionChange', this, option);\n            },\n            getOption: function (option) {\n                return this.options[option];\n            },\n            getDoc: function () {\n                return this.doc;\n            },\n            addKeyMap: function (map, bottom) {\n                this.state.keyMaps[bottom ? 'push' : 'unshift'](k.getKeyMap(map));\n            },\n            removeKeyMap: function (map) {\n                let maps = this.state.keyMaps;\n                for (let i = 0; i < maps.length; ++i)\n                    if (maps[i] == map || maps[i].name == map) {\n                        maps.splice(i, 1);\n                        return true;\n                    }\n            },\n            addOverlay: m.methodOp(function (spec, options) {\n                let mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n                if (mode.startState)\n                    throw new Error('Overlays may not be stateful.');\n                u.insertSorted(this.state.overlays, {\n                    mode: mode,\n                    modeSpec: spec,\n                    opaque: options && options.opaque,\n                    priority: options && options.priority || 0\n                }, overlay => overlay.priority);\n                this.state.modeGen++;\n                x.regChange(this);\n            }),\n            removeOverlay: m.methodOp(function (spec) {\n                let overlays = this.state.overlays;\n                for (let i = 0; i < overlays.length; ++i) {\n                    let cur = overlays[i].modeSpec;\n                    if (cur == spec || typeof spec == 'string' && cur.name == spec) {\n                        overlays.splice(i, 1);\n                        this.state.modeGen++;\n                        x.regChange(this);\n                        return;\n                    }\n                }\n            }),\n            indentLine: m.methodOp(function (n, dir, aggressive) {\n                if (typeof dir != 'string' && typeof dir != 'number') {\n                    if (dir == null)\n                        dir = this.options.smartIndent ? 'smart' : 'prev';\n                    else\n                        dir = dir ? 'add' : 'subtract';\n                }\n                if (w.isLine(this.doc, n))\n                    g.indentLine(this, n, dir, aggressive);\n            }),\n            indentSelection: m.methodOp(function (how) {\n                let ranges = this.doc.sel.ranges, end = -1;\n                for (let i = 0; i < ranges.length; i++) {\n                    let range = ranges[i];\n                    if (!range.empty()) {\n                        let from = range.from(), to = range.to();\n                        let start = Math.max(end, from.line);\n                        end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n                        for (let j = start; j < end; ++j)\n                            g.indentLine(this, j, how);\n                        let newRanges = this.doc.sel.ranges;\n                        if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n                            q.replaceOneSelection(this.doc, i, new p.Range(from, newRanges[i].to()), u.sel_dontScroll);\n                    } else if (range.head.line > end) {\n                        g.indentLine(this, range.head.line, how, true);\n                        end = range.head.line;\n                        if (i == this.doc.sel.primIndex)\n                            r.ensureCursorVisible(this);\n                    }\n                }\n            }),\n            getTokenAt: function (pos, precise) {\n                return f.takeToken(this, pos, precise);\n            },\n            getLineTokens: function (line, precise) {\n                return f.takeToken(this, n.Pos(line), precise, true);\n            },\n            getTokenTypeAt: function (pos) {\n                pos = n.clipPos(this.doc, pos);\n                let styles = f.getLineStyles(this, w.getLine(this.doc, pos.line));\n                let before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n                let type;\n                if (ch == 0)\n                    type = styles[2];\n                else\n                    for (;;) {\n                        let mid = before + after >> 1;\n                        if ((mid ? styles[mid * 2 - 1] : 0) >= ch)\n                            after = mid;\n                        else if (styles[mid * 2 + 1] < ch)\n                            before = mid + 1;\n                        else {\n                            type = styles[mid * 2 + 2];\n                            break;\n                        }\n                    }\n                let cut = type ? type.undefined('overlay ') : -1;\n                return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n            },\n            getModeAt: function (pos) {\n                let mode = this.doc.mode;\n                if (!mode.innerMode)\n                    return mode;\n                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n            },\n            getHelper: function (pos, type) {\n                return this.getHelpers(pos, type)[0];\n            },\n            getHelpers: function (pos, type) {\n                let found = [];\n                if (!helpers.hasOwnProperty(type))\n                    return found;\n                let help = helpers[type], mode = this.getModeAt(pos);\n                if (typeof mode[type] == 'string') {\n                    if (help[mode[type]])\n                        found.push(help[mode[type]]);\n                } else if (mode[type]) {\n                    for (let i = 0; i < mode[type].length; i++) {\n                        let val = help[mode[type][i]];\n                        if (val)\n                            found.push(val);\n                    }\n                } else if (mode.helperType && help[mode.helperType]) {\n                    found.push(help[mode.helperType]);\n                } else if (help[mode.name]) {\n                    found.push(help[mode.name]);\n                }\n                for (let i = 0; i < help._global.length; i++) {\n                    let cur = help._global[i];\n                    if (cur.pred(mode, this) && u.indexOf(found, cur.val) == -1)\n                        found.push(cur.val);\n                }\n                return found;\n            },\n            getStateAfter: function (line, precise) {\n                let doc = this.doc;\n                line = n.clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n                return f.getContextBefore(this, line + 1, precise).state;\n            },\n            cursorCoords: function (start, mode) {\n                let pos, range = this.doc.sel.primary();\n                if (start == null)\n                    pos = range.head;\n                else if (typeof start == 'object')\n                    pos = n.clipPos(this.doc, start);\n                else\n                    pos = start ? range.from() : range.to();\n                return o.cursorCoords(this, pos, mode || 'page');\n            },\n            charCoords: function (pos, mode) {\n                return o.charCoords(this, n.clipPos(this.doc, pos), mode || 'page');\n            },\n            coordsChar: function (coords, mode) {\n                coords = o.fromCoordSystem(this, coords, mode || 'page');\n                return o.coordsChar(this, coords.left, coords.top);\n            },\n            lineAtHeight: function (height, mode) {\n                height = o.fromCoordSystem(this, {\n                    top: height,\n                    left: 0\n                }, mode || 'page').top;\n                return w.lineAtHeight(this.doc, height + this.display.viewOffset);\n            },\n            heightAtLine: function (line, mode, includeWidgets) {\n                let end = false, lineObj;\n                if (typeof line == 'number') {\n                    let last = this.doc.first + this.doc.size - 1;\n                    if (line < this.doc.first)\n                        line = this.doc.first;\n                    else if (line > last) {\n                        line = last;\n                        end = true;\n                    }\n                    lineObj = w.getLine(this.doc, line);\n                } else {\n                    lineObj = line;\n                }\n                return o.intoCoordSystem(this, lineObj, {\n                    top: 0,\n                    left: 0\n                }, mode || 'page', includeWidgets || end).top + (end ? this.doc.height - s.heightAtLine(lineObj) : 0);\n            },\n            defaultTextHeight: function () {\n                return o.textHeight(this.display);\n            },\n            defaultCharWidth: function () {\n                return o.charWidth(this.display);\n            },\n            getViewport: function () {\n                return {\n                    from: this.display.viewFrom,\n                    to: this.display.viewTo\n                };\n            },\n            addWidget: function (pos, node, scroll, vert, horiz) {\n                let display = this.display;\n                pos = o.cursorCoords(this, n.clipPos(this.doc, pos));\n                let top = pos.bottom, left = pos.left;\n                node.style.position = 'absolute';\n                node.setAttribute('cm-ignore-events', 'true');\n                this.display.input.setUneditable(node);\n                display.sizer.appendChild(node);\n                if (vert == 'over') {\n                    top = pos.top;\n                } else if (vert == 'above' || vert == 'near') {\n                    let vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n                        top = pos.top - node.offsetHeight;\n                    else if (pos.bottom + node.offsetHeight <= vspace)\n                        top = pos.bottom;\n                    if (left + node.offsetWidth > hspace)\n                        left = hspace - node.offsetWidth;\n                }\n                node.style.top = top + 'px';\n                node.style.left = node.style.right = '';\n                if (horiz == 'right') {\n                    left = display.sizer.clientWidth - node.offsetWidth;\n                    node.style.right = '0px';\n                } else {\n                    if (horiz == 'left')\n                        left = 0;\n                    else if (horiz == 'middle')\n                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n                    node.style.left = left + 'px';\n                }\n                if (scroll)\n                    r.scrollIntoView(this, {\n                        left,\n                        top,\n                        right: left + node.offsetWidth,\n                        bottom: top + node.offsetHeight\n                    });\n            },\n            triggerOnKeyDown: m.methodOp(i.onKeyDown),\n            triggerOnKeyPress: m.methodOp(i.onKeyPress),\n            triggerOnKeyUp: i.onKeyUp,\n            triggerOnMouseDown: m.methodOp(j.onMouseDown),\n            execCommand: function (cmd) {\n                if (b.commands.hasOwnProperty(cmd))\n                    return b.commands[cmd].call(null, this);\n            },\n            triggerElectric: m.methodOp(function (text) {\n                h.triggerElectric(this, text);\n            }),\n            findPosH: function (from, amount, unit, visually) {\n                let dir = 1;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                let cur = n.clipPos(this.doc, from);\n                for (let i = 0; i < amount; ++i) {\n                    cur = findPosH(this.doc, cur, dir, unit, visually);\n                    if (cur.hitSide)\n                        break;\n                }\n                return cur;\n            },\n            moveH: m.methodOp(function (dir, unit) {\n                this.extendSelectionsBy(range => {\n                    if (this.display.shift || this.doc.extend || range.empty())\n                        return findPosH(this.doc, range.head, dir, unit, this.options.rtlMoveVisually);\n                    else\n                        return dir < 0 ? range.from() : range.to();\n                }, u.sel_move);\n            }),\n            deleteH: m.methodOp(function (dir, unit) {\n                let sel = this.doc.sel, doc = this.doc;\n                if (sel.somethingSelected())\n                    doc.replaceSelection('', null, '+delete');\n                else\n                    a.deleteNearSelection(this, range => {\n                        let other = findPosH(doc, range.head, dir, unit, false);\n                        return dir < 0 ? {\n                            from: other,\n                            to: range.head\n                        } : {\n                            from: range.head,\n                            to: other\n                        };\n                    });\n            }),\n            findPosV: function (from, amount, unit, goalColumn) {\n                let dir = 1, x = goalColumn;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                let cur = n.clipPos(this.doc, from);\n                for (let i = 0; i < amount; ++i) {\n                    let coords = o.cursorCoords(this, cur, 'div');\n                    if (x == null)\n                        x = coords.left;\n                    else\n                        coords.left = x;\n                    cur = findPosV(this, coords, dir, unit);\n                    if (cur.hitSide)\n                        break;\n                }\n                return cur;\n            },\n            moveV: m.methodOp(function (dir, unit) {\n                let doc = this.doc, goals = [];\n                let collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n                doc.extendSelectionsBy(range => {\n                    if (collapse)\n                        return dir < 0 ? range.from() : range.to();\n                    let headPos = o.cursorCoords(this, range.head, 'div');\n                    if (range.goalColumn != null)\n                        headPos.left = range.goalColumn;\n                    goals.push(headPos.left);\n                    let pos = findPosV(this, headPos, dir, unit);\n                    if (unit == 'page' && range == doc.sel.primary())\n                        r.addToScrollTop(this, o.charCoords(this, pos, 'div').top - headPos.top);\n                    return pos;\n                }, u.sel_move);\n                if (goals.length)\n                    for (let i = 0; i < doc.sel.ranges.length; i++)\n                        doc.sel.ranges[i].goalColumn = goals[i];\n            }),\n            findWordAt: function (pos) {\n                let doc = this.doc, line = w.getLine(doc, pos.line).text;\n                let start = pos.ch, end = pos.ch;\n                if (line) {\n                    let helper = this.getHelper(pos, 'wordChars');\n                    if ((pos.sticky == 'before' || end == line.length) && start)\n                        --start;\n                    else\n                        ++end;\n                    let startChar = line.charAt(start);\n                    let check = u.isWordChar(startChar, helper) ? ch => u.isWordChar(ch, helper) : /\\s/.test(startChar) ? ch => /\\s/.test(ch) : ch => !/\\s/.test(ch) && !u.isWordChar(ch);\n                    while (start > 0 && check(line.charAt(start - 1)))\n                        --start;\n                    while (end < line.length && check(line.charAt(end)))\n                        ++end;\n                }\n                return new p.Range(n.Pos(pos.line, start), n.Pos(pos.line, end));\n            },\n            toggleOverwrite: function (value) {\n                if (value != null && value == this.state.overwrite)\n                    return;\n                if (this.state.overwrite = !this.state.overwrite)\n                    d.addClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                else\n                    d.rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                e.signal(this, 'overwriteToggle', this, this.state.overwrite);\n            },\n            hasFocus: function () {\n                return this.display.input.getField() == d.activeElt();\n            },\n            isReadOnly: function () {\n                return !!(this.options.readOnly || this.doc.cantEdit);\n            },\n            scrollTo: m.methodOp(function (x, y) {\n                r.scrollToCoords(this, x, y);\n            }),\n            getScrollInfo: function () {\n                let scroller = this.display.scroller;\n                return {\n                    left: scroller.scrollLeft,\n                    top: scroller.scrollTop,\n                    height: scroller.scrollHeight - o.scrollGap(this) - this.display.barHeight,\n                    width: scroller.scrollWidth - o.scrollGap(this) - this.display.barWidth,\n                    clientHeight: o.displayHeight(this),\n                    clientWidth: o.displayWidth(this)\n                };\n            },\n            scrollIntoView: m.methodOp(function (range, margin) {\n                if (range == null) {\n                    range = {\n                        from: this.doc.sel.primary().head,\n                        to: null\n                    };\n                    if (margin == null)\n                        margin = this.options.cursorScrollMargin;\n                } else if (typeof range == 'number') {\n                    range = {\n                        from: n.Pos(range, 0),\n                        to: null\n                    };\n                } else if (range.from == null) {\n                    range = {\n                        from: range,\n                        to: null\n                    };\n                }\n                if (!range.to)\n                    range.to = range.from;\n                range.margin = margin || 0;\n                if (range.from.line != null) {\n                    r.scrollToRange(this, range);\n                } else {\n                    r.scrollToCoordsRange(this, range.from, range.to, range.margin);\n                }\n            }),\n            setSize: m.methodOp(function (width, height) {\n                let interpret = val => typeof val == 'number' || /^\\d+$/.test(String(val)) ? val + 'px' : val;\n                if (width != null)\n                    this.display.wrapper.style.width = interpret(width);\n                if (height != null)\n                    this.display.wrapper.style.height = interpret(height);\n                if (this.options.lineWrapping)\n                    o.clearLineMeasurementCache(this);\n                let lineNo = this.display.viewFrom;\n                this.doc.iter(lineNo, this.display.viewTo, line => {\n                    if (line.widgets)\n                        for (let i = 0; i < line.widgets.length; i++)\n                            if (line.widgets[i].noHScroll) {\n                                x.regLineChange(this, lineNo, 'widget');\n                                break;\n                            }\n                    ++lineNo;\n                });\n                this.curOp.forceUpdate = true;\n                e.signal(this, 'refresh', this);\n            }),\n            operation: function (f) {\n                return m.runInOp(this, f);\n            },\n            startOperation: function () {\n                return m.startOperation(this);\n            },\n            endOperation: function () {\n                return m.endOperation(this);\n            },\n            refresh: m.methodOp(function () {\n                let oldHeight = this.display.cachedTextHeight;\n                x.regChange(this);\n                this.curOp.forceUpdate = true;\n                o.clearCaches(this);\n                r.scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n                t.updateGutterSpace(this);\n                if (oldHeight == null || Math.abs(oldHeight - o.textHeight(this.display)) > 0.5)\n                    o.estimateLineHeights(this);\n                e.signal(this, 'refresh', this);\n            }),\n            swapDoc: m.methodOp(function (doc) {\n                let old = this.doc;\n                old.cm = null;\n                c.attachDoc(this, doc);\n                o.clearCaches(this);\n                this.display.input.reset();\n                r.scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n                this.curOp.forceScroll = true;\n                v.signalLater(this, 'swapDoc', this, old);\n                return old;\n            }),\n            phrase: function (phraseText) {\n                let phrases = this.options.phrases;\n                return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n            },\n            getInputField: function () {\n                return this.display.input.getField();\n            },\n            getWrapperElement: function () {\n                return this.display.wrapper;\n            },\n            getScrollerElement: function () {\n                return this.display.scroller;\n            },\n            getGutterElement: function () {\n                return this.display.gutters;\n            }\n        };\n        e.eventMixin(CodeMirror);\n        CodeMirror.registerHelper = function (type, name, value) {\n            if (!helpers.hasOwnProperty(type))\n                helpers[type] = CodeMirror[type] = { _global: [] };\n            helpers[type][name] = value;\n        };\n        CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {\n            CodeMirror.registerHelper(type, name, value);\n            helpers[type]._global.push({\n                pred: predicate,\n                val: value\n            });\n        };\n    };\n    function findPosH(doc, pos, dir, unit, visually) {\n        let oldPos = pos;\n        let origDir = dir;\n        let lineObj = w.getLine(doc, pos.line);\n        function findNextLine() {\n            let l = pos.line + dir;\n            if (l < doc.first || l >= doc.first + doc.size)\n                return false;\n            pos = new n.Pos(l, pos.ch, pos.sticky);\n            return lineObj = w.getLine(doc, l);\n        }\n        function moveOnce(boundToLine) {\n            let next;\n            if (visually) {\n                next = l.moveVisually(doc.cm, lineObj, pos, dir);\n            } else {\n                next = l.moveLogically(lineObj, pos, dir);\n            }\n            if (next == null) {\n                if (!boundToLine && findNextLine())\n                    pos = l.endOfLine(visually, doc.cm, lineObj, pos.line, dir);\n                else\n                    return false;\n            } else {\n                pos = next;\n            }\n            return true;\n        }\n        if (unit == 'char') {\n            moveOnce();\n        } else if (unit == 'column') {\n            moveOnce(true);\n        } else if (unit == 'word' || unit == 'group') {\n            let sawType = null, group = unit == 'group';\n            let helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');\n            for (let first = true;; first = false) {\n                if (dir < 0 && !moveOnce(!first))\n                    break;\n                let cur = lineObj.text.charAt(pos.ch) || '\\n';\n                let type = u.isWordChar(cur, helper) ? 'w' : group && cur == '\\n' ? 'n' : !group || /\\s/.test(cur) ? null : 'p';\n                if (group && !first && !type)\n                    type = 's';\n                if (sawType && sawType != type) {\n                    if (dir < 0) {\n                        dir = 1;\n                        moveOnce();\n                        pos.sticky = 'after';\n                    }\n                    break;\n                }\n                if (type)\n                    sawType = type;\n                if (dir > 0 && !moveOnce(!first))\n                    break;\n            }\n        }\n        let result = q.skipAtomic(doc, pos, oldPos, origDir, true);\n        if (n.equalCursorPos(oldPos, result))\n            result.hitSide = true;\n        return result;\n    }\n    function findPosV(cm, pos, dir, unit) {\n        let doc = cm.doc, x = pos.left, y;\n        if (unit == 'page') {\n            let pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n            let moveAmount = Math.max(pageSize - 0.5 * o.textHeight(cm.display), 3);\n            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n        } else if (unit == 'line') {\n            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n        }\n        let target;\n        for (;;) {\n            target = o.coordsChar(cm, x, y);\n            if (!target.outside)\n                break;\n            if (dir < 0 ? y <= 0 : y >= doc.height) {\n                target.hitSide = true;\n                break;\n            }\n            y += dir * 5;\n        }\n        return target;\n    }\n});"]}