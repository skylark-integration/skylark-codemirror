{"version":3,"sources":["primitives/input/ContentEditableInput.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","ContentEditableInput","[object Object]","cm","this","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","Delayed","composing","gracePeriod","readDOMTimeout","display","input","div","lineDiv","onCopyCut","signalDOMEvent","somethingSelected","setLastCopied","lineWise","text","getSelections","type","replaceSelection","options","lineWiseCopyCut","ranges","copyableRanges","operation","setSelections","sel_dontScroll","clipboardData","clearData","content","lastCopied","join","setData","getData","preventDefault","kludge","hiddenTextarea","te","firstChild","lineSpace","insertBefore","value","hadFocus","document","activeElement","selectInput","setTimeout","removeChild","focus","showPrimarySelection","disableBrowserMagic","spellcheck","autocorrect","autocapitalize","on","handlePaste","ie_version","updateFromDOM","data","done","readFromDOMSoon","forceCompositionEnd","result","prepareSelection","state","focused","info","takeFocus","view","length","showMultipleSelections","wrapper","ownerDocument","getSelection","sel","prim","doc","primary","from","to","viewTo","viewFrom","line","removeAllRanges","curAnchor","domToPos","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","bad","cmp","minPos","maxPos","start","posToDOM","node","measure","map","offset","end","maps","rng","old","rangeCount","getRangeAt","range","gecko","collapse","collapsed","addRange","startGracePeriod","rememberSelection","clearTimeout","selectionChanged","curOp","removeChildrenAndAdd","cursorDiv","cursors","selectionDiv","selection","commonAncestorContainer","contains","readOnly","selectionInEditor","showSelection","blur","pollSelection","runInOp","set","pollInterval","poll","android","chrome","gutters","scan","parentNode","test","className","isInGutter","triggerOnKeyDown","keyCode","Math","abs","anchor","head","setSelection","simpleSelection","fromIndex","fromLine","fromNode","ch","firstLine","Pos","getLine","lastLine","findViewIndex","lineNo","nextSibling","toLine","toNode","toIndex","lastChild","previousSibling","newText","splitLines","closing","lineSep","lineSeparator","extraLinebreak","close","addText","str","walk","nodeType","cmText","getAttribute","markerID","found","findMarks","id","marker","find","getBetween","isBlock","nodeName","textContent","childNodes","nodeValue","replace","domTextBetween","oldText","lst","pop","shift","cutFront","cutEnd","newTop","oldTop","maxCutFront","min","charCodeAt","newBot","oldBot","maxCutEnd","slice","chFrom","chTo","replaceRange","isReadOnly","pollContent","regChange","contentEditable","charCode","applyTextInput","String","fromCharCode","val","pos","findViewForLine","hidden","mapFromLineView","order","getOrder","direction","side","getBidiPartAt","nodeAndOffsetInLineMap","badPos","lineNode","clipPos","lineView","locateNodeInLineView","rest","textNode","topNode","curNode","after","dist","before","prototype","needsContentAttribute"],"mappings":"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","file":"../../../primitives/input/ContentEditableInput.js","sourcesContent":["define([\n    '../display/operations',\n    '../display/selection',\n    '../display/view_tracking',\n    './input',\n    '../line/pos',\n    '../line/utils_line',\n    '../measurement/position_measurement',\n    '../model/changes',\n    '../model/selection',\n    '../model/selection_updates',\n    '../util/bidi',\n    '../util/browser',\n    '../util/dom',\n    '../util/event',\n    '../util/misc'\n], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {\n    'use strict';\n    class ContentEditableInput {\n        constructor(cm) {\n            this.cm = cm;\n            this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n            this.polling = new o.Delayed();\n            this.composing = null;\n            this.gracePeriod = false;\n            this.readDOMTimeout = null;\n        }\n        init(display) {\n            let input = this, cm = input.cm;\n            let div = input.div = display.lineDiv;\n            d.disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n            n.on(div, 'paste', e => {\n                if (n.signalDOMEvent(cm, e) || d.handlePaste(e, cm))\n                    return;\n                if (l.ie_version <= 11)\n                    setTimeout(a.operation(cm, () => this.updateFromDOM()), 20);\n            });\n            n.on(div, 'compositionstart', e => {\n                this.composing = {\n                    data: e.data,\n                    done: false\n                };\n            });\n            n.on(div, 'compositionupdate', e => {\n                if (!this.composing)\n                    this.composing = {\n                        data: e.data,\n                        done: false\n                    };\n            });\n            n.on(div, 'compositionend', e => {\n                if (this.composing) {\n                    if (e.data != this.composing.data)\n                        this.readFromDOMSoon();\n                    this.composing.done = true;\n                }\n            });\n            n.on(div, 'touchstart', () => input.forceCompositionEnd());\n            n.on(div, 'input', () => {\n                if (!this.composing)\n                    this.readFromDOMSoon();\n            });\n            function onCopyCut(e) {\n                if (n.signalDOMEvent(cm, e))\n                    return;\n                if (cm.somethingSelected()) {\n                    d.setLastCopied({\n                        lineWise: false,\n                        text: cm.getSelections()\n                    });\n                    if (e.type == 'cut')\n                        cm.replaceSelection('', null, 'cut');\n                } else if (!cm.options.lineWiseCopyCut) {\n                    return;\n                } else {\n                    let ranges = d.copyableRanges(cm);\n                    d.setLastCopied({\n                        lineWise: true,\n                        text: ranges.text\n                    });\n                    if (e.type == 'cut') {\n                        cm.operation(() => {\n                            cm.setSelections(ranges.ranges, 0, o.sel_dontScroll);\n                            cm.replaceSelection('', null, 'cut');\n                        });\n                    }\n                }\n                if (e.clipboardData) {\n                    e.clipboardData.clearData();\n                    let content = d.lastCopied.text.join('\\n');\n                    e.clipboardData.setData('Text', content);\n                    if (e.clipboardData.getData('Text') == content) {\n                        e.preventDefault();\n                        return;\n                    }\n                }\n                let kludge = d.hiddenTextarea(), te = kludge.firstChild;\n                cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n                te.value = d.lastCopied.text.join('\\n');\n                let hadFocus = document.activeElement;\n                m.selectInput(te);\n                setTimeout(() => {\n                    cm.display.lineSpace.removeChild(kludge);\n                    hadFocus.focus();\n                    if (hadFocus == div)\n                        input.showPrimarySelection();\n                }, 50);\n            }\n            n.on(div, 'copy', onCopyCut);\n            n.on(div, 'cut', onCopyCut);\n        }\n        prepareSelection() {\n            let result = b.prepareSelection(this.cm, false);\n            result.focus = this.cm.state.focused;\n            return result;\n        }\n        showSelection(info, takeFocus) {\n            if (!info || !this.cm.display.view.length)\n                return;\n            if (info.focus || takeFocus)\n                this.showPrimarySelection();\n            this.showMultipleSelections(info);\n        }\n        getSelection() {\n            return this.cm.display.wrapper.ownerDocument.getSelection();\n        }\n        showPrimarySelection() {\n            let sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n            let from = prim.from(), to = prim.to();\n            if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n                sel.removeAllRanges();\n                return;\n            }\n            let curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n            let curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n            if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && e.cmp(e.minPos(curAnchor, curFocus), from) == 0 && e.cmp(e.maxPos(curAnchor, curFocus), to) == 0)\n                return;\n            let view = cm.display.view;\n            let start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n                node: view[0].measure.map[2],\n                offset: 0\n            };\n            let end = to.line < cm.display.viewTo && posToDOM(cm, to);\n            if (!end) {\n                let measure = view[view.length - 1].measure;\n                let map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n                end = {\n                    node: map[map.length - 1],\n                    offset: map[map.length - 2] - map[map.length - 3]\n                };\n            }\n            if (!start || !end) {\n                sel.removeAllRanges();\n                return;\n            }\n            let old = sel.rangeCount && sel.getRangeAt(0), rng;\n            try {\n                rng = m.range(start.node, start.offset, end.offset, end.node);\n            } catch (e) {\n            }\n            if (rng) {\n                if (!l.gecko && cm.state.focused) {\n                    sel.collapse(start.node, start.offset);\n                    if (!rng.collapsed) {\n                        sel.removeAllRanges();\n                        sel.addRange(rng);\n                    }\n                } else {\n                    sel.removeAllRanges();\n                    sel.addRange(rng);\n                }\n                if (old && sel.anchorNode == null)\n                    sel.addRange(old);\n                else if (l.gecko)\n                    this.startGracePeriod();\n            }\n            this.rememberSelection();\n        }\n        startGracePeriod() {\n            clearTimeout(this.gracePeriod);\n            this.gracePeriod = setTimeout(() => {\n                this.gracePeriod = false;\n                if (this.selectionChanged())\n                    this.cm.operation(() => this.cm.curOp.selectionChanged = true);\n            }, 20);\n        }\n        showMultipleSelections(info) {\n            m.removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n            m.removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n        }\n        rememberSelection() {\n            let sel = this.getSelection();\n            this.lastAnchorNode = sel.anchorNode;\n            this.lastAnchorOffset = sel.anchorOffset;\n            this.lastFocusNode = sel.focusNode;\n            this.lastFocusOffset = sel.focusOffset;\n        }\n        selectionInEditor() {\n            let sel = this.getSelection();\n            if (!sel.rangeCount)\n                return false;\n            let node = sel.getRangeAt(0).commonAncestorContainer;\n            return m.contains(this.div, node);\n        }\n        focus() {\n            if (this.cm.options.readOnly != 'nocursor') {\n                if (!this.selectionInEditor())\n                    this.showSelection(this.prepareSelection(), true);\n                this.div.focus();\n            }\n        }\n        blur() {\n            this.div.blur();\n        }\n        getField() {\n            return this.div;\n        }\n        supportsTouch() {\n            return true;\n        }\n        receivedFocus() {\n            let input = this;\n            if (this.selectionInEditor())\n                this.pollSelection();\n            else\n                a.runInOp(this.cm, () => input.cm.curOp.selectionChanged = true);\n            function poll() {\n                if (input.cm.state.focused) {\n                    input.pollSelection();\n                    input.polling.set(input.cm.options.pollInterval, poll);\n                }\n            }\n            this.polling.set(this.cm.options.pollInterval, poll);\n        }\n        selectionChanged() {\n            let sel = this.getSelection();\n            return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n        }\n        pollSelection() {\n            if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())\n                return;\n            let sel = this.getSelection(), cm = this.cm;\n            if (l.android && l.chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n                this.cm.triggerOnKeyDown({\n                    type: 'keydown',\n                    keyCode: 8,\n                    preventDefault: Math.abs\n                });\n                this.blur();\n                this.focus();\n                return;\n            }\n            if (this.composing)\n                return;\n            this.rememberSelection();\n            let anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n            let head = domToPos(cm, sel.focusNode, sel.focusOffset);\n            if (anchor && head)\n                a.runInOp(cm, () => {\n                    j.setSelection(cm.doc, i.simpleSelection(anchor, head), o.sel_dontScroll);\n                    if (anchor.bad || head.bad)\n                        cm.curOp.selectionChanged = true;\n                });\n        }\n        pollContent() {\n            if (this.readDOMTimeout != null) {\n                clearTimeout(this.readDOMTimeout);\n                this.readDOMTimeout = null;\n            }\n            let cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n            let from = sel.from(), to = sel.to();\n            if (from.ch == 0 && from.line > cm.firstLine())\n                from = e.Pos(from.line - 1, f.getLine(cm.doc, from.line - 1).length);\n            if (to.ch == f.getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n                to = e.Pos(to.line + 1, 0);\n            if (from.line < display.viewFrom || to.line > display.viewTo - 1)\n                return false;\n            let fromIndex, fromLine, fromNode;\n            if (from.line == display.viewFrom || (fromIndex = g.findViewIndex(cm, from.line)) == 0) {\n                fromLine = f.lineNo(display.view[0].line);\n                fromNode = display.view[0].node;\n            } else {\n                fromLine = f.lineNo(display.view[fromIndex].line);\n                fromNode = display.view[fromIndex - 1].node.nextSibling;\n            }\n            let toIndex = g.findViewIndex(cm, to.line);\n            let toLine, toNode;\n            if (toIndex == display.view.length - 1) {\n                toLine = display.viewTo - 1;\n                toNode = display.lineDiv.lastChild;\n            } else {\n                toLine = f.lineNo(display.view[toIndex + 1].line) - 1;\n                toNode = display.view[toIndex + 1].node.previousSibling;\n            }\n            if (!fromNode)\n                return false;\n            let newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n            let oldText = f.getBetween(cm.doc, e.Pos(fromLine, 0), e.Pos(toLine, f.getLine(cm.doc, toLine).text.length));\n            while (newText.length > 1 && oldText.length > 1) {\n                if (o.lst(newText) == o.lst(oldText)) {\n                    newText.pop();\n                    oldText.pop();\n                    toLine--;\n                } else if (newText[0] == oldText[0]) {\n                    newText.shift();\n                    oldText.shift();\n                    fromLine++;\n                } else\n                    break;\n            }\n            let cutFront = 0, cutEnd = 0;\n            let newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n            while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n                ++cutFront;\n            let newBot = o.lst(newText), oldBot = o.lst(oldText);\n            let maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n            while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n                ++cutEnd;\n            if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n                while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n                    cutFront--;\n                    cutEnd++;\n                }\n            }\n            newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, '');\n            newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, '');\n            let chFrom = e.Pos(fromLine, cutFront);\n            let chTo = e.Pos(toLine, oldText.length ? o.lst(oldText).length - cutEnd : 0);\n            if (newText.length > 1 || newText[0] || e.cmp(chFrom, chTo)) {\n                h.replaceRange(cm.doc, newText, chFrom, chTo, '+input');\n                return true;\n            }\n        }\n        ensurePolled() {\n            this.forceCompositionEnd();\n        }\n        reset() {\n            this.forceCompositionEnd();\n        }\n        forceCompositionEnd() {\n            if (!this.composing)\n                return;\n            clearTimeout(this.readDOMTimeout);\n            this.composing = null;\n            this.updateFromDOM();\n            this.div.blur();\n            this.div.focus();\n        }\n        readFromDOMSoon() {\n            if (this.readDOMTimeout != null)\n                return;\n            this.readDOMTimeout = setTimeout(() => {\n                this.readDOMTimeout = null;\n                if (this.composing) {\n                    if (this.composing.done)\n                        this.composing = null;\n                    else\n                        return;\n                }\n                this.updateFromDOM();\n            }, 80);\n        }\n        updateFromDOM() {\n            if (this.cm.isReadOnly() || !this.pollContent())\n                a.runInOp(this.cm, () => c.regChange(this.cm));\n        }\n        setUneditable(node) {\n            node.contentEditable = 'false';\n        }\n        onKeyPress(e) {\n            if (e.charCode == 0 || this.composing)\n                return;\n            e.preventDefault();\n            if (!this.cm.isReadOnly())\n                a.operation(this.cm, d.applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n        }\n        readOnlyChanged(val) {\n            this.div.contentEditable = String(val != 'nocursor');\n        }\n        onContextMenu() {\n        }\n        resetPosition() {\n        }\n    };\n    ContentEditableInput.prototype.needsContentAttribute = true;\n    function posToDOM(cm, pos) {\n        let view = g.findViewForLine(cm, pos.line);\n        if (!view || view.hidden)\n            return null;\n        let line = f.getLine(cm.doc, pos.line);\n        let info = g.mapFromLineView(view, line, pos.line);\n        let order = k.getOrder(line, cm.doc.direction), side = 'left';\n        if (order) {\n            let partPos = k.getBidiPartAt(order, pos.ch);\n            side = partPos % 2 ? 'right' : 'left';\n        }\n        let result = g.nodeAndOffsetInLineMap(info.map, pos.ch, side);\n        result.offset = result.collapse == 'right' ? result.end : result.start;\n        return result;\n    }\n    function isInGutter(node) {\n        for (let scan = node; scan; scan = scan.parentNode)\n            if (/CodeMirror-gutter-wrapper/.test(scan.className))\n                return true;\n        return false;\n    }\n    function badPos(pos, bad) {\n        if (bad)\n            pos.bad = true;\n        return pos;\n    }\n    function domTextBetween(cm, from, to, fromLine, toLine) {\n        let text = '', closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n        function recognizeMarker(id) {\n            return marker => marker.id == id;\n        }\n        function close() {\n            if (closing) {\n                text += lineSep;\n                if (extraLinebreak)\n                    text += lineSep;\n                closing = extraLinebreak = false;\n            }\n        }\n        function addText(str) {\n            if (str) {\n                close();\n                text += str;\n            }\n        }\n        function walk(node) {\n            if (node.nodeType == 1) {\n                let cmText = node.getAttribute('cm-text');\n                if (cmText) {\n                    addText(cmText);\n                    return;\n                }\n                let markerID = node.getAttribute('cm-marker'), range;\n                if (markerID) {\n                    let found = cm.findMarks(e.Pos(fromLine, 0), e.Pos(toLine + 1, 0), recognizeMarker(+markerID));\n                    if (found.length && (range = found[0].find(0)))\n                        addText(f.getBetween(cm.doc, range.from, range.to).join(lineSep));\n                    return;\n                }\n                if (node.getAttribute('contenteditable') == 'false')\n                    return;\n                let isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n                if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0)\n                    return;\n                if (isBlock)\n                    close();\n                for (let i = 0; i < node.childNodes.length; i++)\n                    walk(node.childNodes[i]);\n                if (/^(pre|p)$/i.test(node.nodeName))\n                    extraLinebreak = true;\n                if (isBlock)\n                    closing = true;\n            } else if (node.nodeType == 3) {\n                addText(node.nodeValue.replace(/\\u200b/g, '').replace(/\\u00a0/g, ' '));\n            }\n        }\n        for (;;) {\n            walk(from);\n            if (from == to)\n                break;\n            from = from.nextSibling;\n            extraLinebreak = false;\n        }\n        return text;\n    }\n    function domToPos(cm, node, offset) {\n        let lineNode;\n        if (node == cm.display.lineDiv) {\n            lineNode = cm.display.lineDiv.childNodes[offset];\n            if (!lineNode)\n                return badPos(cm.clipPos(e.Pos(cm.display.viewTo - 1)), true);\n            node = null;\n            offset = 0;\n        } else {\n            for (lineNode = node;; lineNode = lineNode.parentNode) {\n                if (!lineNode || lineNode == cm.display.lineDiv)\n                    return null;\n                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)\n                    break;\n            }\n        }\n        for (let i = 0; i < cm.display.view.length; i++) {\n            let lineView = cm.display.view[i];\n            if (lineView.node == lineNode)\n                return locateNodeInLineView(lineView, node, offset);\n        }\n    }\n    function locateNodeInLineView(lineView, node, offset) {\n        let wrapper = lineView.text.firstChild, bad = false;\n        if (!node || !m.contains(wrapper, node))\n            return badPos(e.Pos(f.lineNo(lineView.line), 0), true);\n        if (node == wrapper) {\n            bad = true;\n            node = wrapper.childNodes[offset];\n            offset = 0;\n            if (!node) {\n                let line = lineView.rest ? o.lst(lineView.rest) : lineView.line;\n                return badPos(e.Pos(f.lineNo(line), line.text.length), bad);\n            }\n        }\n        let textNode = node.nodeType == 3 ? node : null, topNode = node;\n        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n            textNode = node.firstChild;\n            if (offset)\n                offset = textNode.nodeValue.length;\n        }\n        while (topNode.parentNode != wrapper)\n            topNode = topNode.parentNode;\n        let measure = lineView.measure, maps = measure.maps;\n        function find(textNode, topNode, offset) {\n            for (let i = -1; i < (maps ? maps.length : 0); i++) {\n                let map = i < 0 ? measure.map : maps[i];\n                for (let j = 0; j < map.length; j += 3) {\n                    let curNode = map[j + 2];\n                    if (curNode == textNode || curNode == topNode) {\n                        let line = f.lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n                        let ch = map[j] + offset;\n                        if (offset < 0 || curNode != textNode)\n                            ch = map[j + (offset ? 1 : 0)];\n                        return e.Pos(line, ch);\n                    }\n                }\n            }\n        }\n        let found = find(textNode, topNode, offset);\n        if (found)\n            return badPos(found, bad);\n        for (let after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n            found = find(after, after.firstChild, 0);\n            if (found)\n                return badPos(e.Pos(found.line, found.ch - dist), bad);\n            else\n                dist += after.textContent.length;\n        }\n        for (let before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n            found = find(before, before.firstChild, -1);\n            if (found)\n                return badPos(e.Pos(found.line, found.ch + dist), bad);\n            else\n                dist += before.textContent.length;\n        }\n    }\n\n    return ContentEditableInput;\n});"]}