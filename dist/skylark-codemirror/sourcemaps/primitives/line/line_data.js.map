{"version":3,"sources":["primitives/line/line_data.js"],"names":["define","a","b","c","d","e","f","g","h","m_utils_line","Line","[object Object]","text","markedSpans","estimateHeight","this","attachMarkedSpans","height","lineNo","eventMixin","styleToClassCache","styleToClassCacheWithMode","interpretTokenStyle","style","options","test","cache","addModeClass","replace","buildToken","builder","startStyle","endStyle","css","attributes","content","displayText","splitSpaces","trailingBefore","length","spaceBefore","result","i","ch","charAt","charCodeAt","trailingSpace","special","cm","state","specialChars","mustWrap","document","createDocumentFragment","pos","lastIndex","txt","m","exec","skipped","index","createTextNode","slice","ie","ie_version","appendChild","elt","map","push","col","tabSize","tabWidth","spaceStr","setAttribute","specialCharPlaceholder","fullStyle","token","attr","hasOwnProperty","buildTokenBadBidi","inner","order","start","end","part","to","from","buildCollapsedSpan","size","marker","ignoreWidget","widget","widgetNode","display","input","needsContentAttribute","createElement","id","setUneditable","insertLineContent","line","styles","spans","allText","at","addToken","spanStyle","spanEndStyle","spanStartStyle","collapsed","len","nextChange","Infinity","endStyles","foundBookmarks","j","sp","type","className","title","compareCollapsedMarkers","upto","Math","min","tokenText","LineView","doc","lineN","rest","visualLineContinued","lst","node","hidden","lineIsHidden","updateLine","stateAfter","detachMarkedSpans","estHeight","updateLineHeight","cleanUpLine","parent","buildLineContent","lineView","eltP","webkit","pre","getOption","measure","hasBadBidiRects","getOrder","direction","allowFrontierUpdate","externalMeasured","getLineStyles","styleClasses","bgClass","joinClasses","textClass","zeroWidthElement","maps","caches","last","lastChild","querySelector","signal","defaultSpecialCharPlaceholder","toString","buildViewArray","nextPos","array","view","getLine"],"mappings":"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","file":"../../../primitives/line/line_data.js","sourcesContent":["define([\n    '../util/bidi',\n    '../util/browser',\n    '../util/dom',\n    '../util/event',\n    '../util/feature_detection',\n    '../util/misc',\n    './highlight',\n    './spans',\n    './utils_line'\n], function (a, b, c, d, e, f, g, h, m_utils_line) {\n    'use strict';\n    class Line {\n        constructor(text, markedSpans, estimateHeight) {\n            this.text = text;\n            h.attachMarkedSpans(this, markedSpans);\n            this.height = estimateHeight ? estimateHeight(this) : 1;\n        }\n        lineNo() {\n            return m_utils_line.lineNo(this);\n        }\n    }\n    d.eventMixin(Line);\n    function updateLine(line, text, markedSpans, estimateHeight) {\n        line.text = text;\n        if (line.stateAfter)\n            line.stateAfter = null;\n        if (line.styles)\n            line.styles = null;\n        if (line.order != null)\n            line.order = null;\n        h.detachMarkedSpans(line);\n        h.attachMarkedSpans(line, markedSpans);\n        let estHeight = estimateHeight ? estimateHeight(line) : 1;\n        if (estHeight != line.height)\n            m_utils_line.updateLineHeight(line, estHeight);\n    }\n    function cleanUpLine(line) {\n        line.parent = null;\n        h.detachMarkedSpans(line);\n    }\n    let styleToClassCache = {}, styleToClassCacheWithMode = {};\n    function interpretTokenStyle(style, options) {\n        if (!style || /^\\s*$/.test(style))\n            return null;\n        let cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n        return cache[style] || (cache[style] = style.replace(/\\S+/g, 'cm-$&'));\n    }\n    function buildLineContent(cm, lineView) {\n        let content = c.eltP('span', null, null, b.webkit ? 'padding-right: .1px' : null);\n        let builder = {\n            pre: c.eltP('pre', [content], 'CodeMirror-line'),\n            content: content,\n            col: 0,\n            pos: 0,\n            cm: cm,\n            trailingSpace: false,\n            splitSpaces: cm.getOption('lineWrapping')\n        };\n        lineView.measure = {};\n        for (let i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n            let line = i ? lineView.rest[i - 1] : lineView.line, order;\n            builder.pos = 0;\n            builder.addToken = buildToken;\n            if (e.hasBadBidiRects(cm.display.measure) && (order = a.getOrder(line, cm.doc.direction)))\n                builder.addToken = buildTokenBadBidi(builder.addToken, order);\n            builder.map = [];\n            let allowFrontierUpdate = lineView != cm.display.externalMeasured && m_utils_line.lineNo(line);\n            insertLineContent(line, builder, g.getLineStyles(cm, line, allowFrontierUpdate));\n            if (line.styleClasses) {\n                if (line.styleClasses.bgClass)\n                    builder.bgClass = c.joinClasses(line.styleClasses.bgClass, builder.bgClass || '');\n                if (line.styleClasses.textClass)\n                    builder.textClass = c.joinClasses(line.styleClasses.textClass, builder.textClass || '');\n            }\n            if (builder.map.length == 0)\n                builder.map.push(0, 0, builder.content.appendChild(e.zeroWidthElement(cm.display.measure)));\n            if (i == 0) {\n                lineView.measure.map = builder.map;\n                lineView.measure.cache = {};\n            } else {\n                ;\n                (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n                (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n            }\n        }\n        if (b.webkit) {\n            let last = builder.content.lastChild;\n            if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector('.cm-tab'))\n                builder.content.className = 'cm-tab-wrap-hack';\n        }\n        d.signal(cm, 'renderLine', cm, lineView.line, builder.pre);\n        if (builder.pre.className)\n            builder.textClass = c.joinClasses(builder.pre.className, builder.textClass || '');\n        return builder;\n    }\n    function defaultSpecialCharPlaceholder(ch) {\n        let token = c.elt('span', '\\u2022', 'cm-invalidchar');\n        token.title = '\\\\u' + ch.charCodeAt(0).toString(16);\n        token.setAttribute('aria-label', token.title);\n        return token;\n    }\n    function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n        if (!text)\n            return;\n        let displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n        let special = builder.cm.state.specialChars, mustWrap = false;\n        let content;\n        if (!special.test(text)) {\n            builder.col += text.length;\n            content = document.createTextNode(displayText);\n            builder.map.push(builder.pos, builder.pos + text.length, content);\n            if (b.ie && b.ie_version < 9)\n                mustWrap = true;\n            builder.pos += text.length;\n        } else {\n            content = document.createDocumentFragment();\n            let pos = 0;\n            while (true) {\n                special.lastIndex = pos;\n                let m = special.exec(text);\n                let skipped = m ? m.index - pos : text.length - pos;\n                if (skipped) {\n                    let txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n                    if (b.ie && b.ie_version < 9)\n                        content.appendChild(c.elt('span', [txt]));\n                    else\n                        content.appendChild(txt);\n                    builder.map.push(builder.pos, builder.pos + skipped, txt);\n                    builder.col += skipped;\n                    builder.pos += skipped;\n                }\n                if (!m)\n                    break;\n                pos += skipped + 1;\n                let txt;\n                if (m[0] == '\\t') {\n                    let tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n                    txt = content.appendChild(c.elt('span', f.spaceStr(tabWidth), 'cm-tab'));\n                    txt.setAttribute('role', 'presentation');\n                    txt.setAttribute('cm-text', '\\t');\n                    builder.col += tabWidth;\n                } else if (m[0] == '\\r' || m[0] == '\\n') {\n                    txt = content.appendChild(c.elt('span', m[0] == '\\r' ? '\\u240D' : '\\u2424', 'cm-invalidchar'));\n                    txt.setAttribute('cm-text', m[0]);\n                    builder.col += 1;\n                } else {\n                    txt = builder.cm.options.specialCharPlaceholder(m[0]);\n                    txt.setAttribute('cm-text', m[0]);\n                    if (b.ie && b.ie_version < 9)\n                        content.appendChild(c.elt('span', [txt]));\n                    else\n                        content.appendChild(txt);\n                    builder.col += 1;\n                }\n                builder.map.push(builder.pos, builder.pos + 1, txt);\n                builder.pos++;\n            }\n        }\n        builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n        if (style || startStyle || endStyle || mustWrap || css) {\n            let fullStyle = style || '';\n            if (startStyle)\n                fullStyle += startStyle;\n            if (endStyle)\n                fullStyle += endStyle;\n            let token = c.elt('span', [content], fullStyle, css);\n            if (attributes) {\n                for (let attr in attributes)\n                    if (attributes.hasOwnProperty(attr) && attr != 'style' && attr != 'class')\n                        token.setAttribute(attr, attributes[attr]);\n            }\n            return builder.content.appendChild(token);\n        }\n        builder.content.appendChild(content);\n    }\n    function splitSpaces(text, trailingBefore) {\n        if (text.length > 1 && !/  /.test(text))\n            return text;\n        let spaceBefore = trailingBefore, result = '';\n        for (let i = 0; i < text.length; i++) {\n            let ch = text.charAt(i);\n            if (ch == ' ' && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n                ch = '\\xA0';\n            result += ch;\n            spaceBefore = ch == ' ';\n        }\n        return result;\n    }\n    function buildTokenBadBidi(inner, order) {\n        return (builder, text, style, startStyle, endStyle, css, attributes) => {\n            style = style ? style + ' cm-force-border' : 'cm-force-border';\n            let start = builder.pos, end = start + text.length;\n            for (;;) {\n                let part;\n                for (let i = 0; i < order.length; i++) {\n                    part = order[i];\n                    if (part.to > start && part.from <= start)\n                        break;\n                }\n                if (part.to >= end)\n                    return inner(builder, text, style, startStyle, endStyle, css, attributes);\n                inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n                startStyle = null;\n                text = text.slice(part.to - start);\n                start = part.to;\n            }\n        };\n    }\n    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n        let widget = !ignoreWidget && marker.widgetNode;\n        if (widget)\n            builder.map.push(builder.pos, builder.pos + size, widget);\n        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n            if (!widget)\n                widget = builder.content.appendChild(document.createElement('span'));\n            widget.setAttribute('cm-marker', marker.id);\n        }\n        if (widget) {\n            builder.cm.display.input.setUneditable(widget);\n            builder.content.appendChild(widget);\n        }\n        builder.pos += size;\n        builder.trailingSpace = false;\n    }\n    function insertLineContent(line, builder, styles) {\n        let spans = line.markedSpans, allText = line.text, at = 0;\n        if (!spans) {\n            for (let i = 1; i < styles.length; i += 2)\n                builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options));\n            return;\n        }\n        let len = allText.length, pos = 0, i = 1, text = '', style, css;\n        let nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n        for (;;) {\n            if (nextChange == pos) {\n                spanStyle = spanEndStyle = spanStartStyle = css = '';\n                attributes = null;\n                collapsed = null;\n                nextChange = Infinity;\n                let foundBookmarks = [], endStyles;\n                for (let j = 0; j < spans.length; ++j) {\n                    let sp = spans[j], m = sp.marker;\n                    if (m.type == 'bookmark' && sp.from == pos && m.widgetNode) {\n                        foundBookmarks.push(m);\n                    } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n                        if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n                            nextChange = sp.to;\n                            spanEndStyle = '';\n                        }\n                        if (m.className)\n                            spanStyle += ' ' + m.className;\n                        if (m.css)\n                            css = (css ? css + ';' : '') + m.css;\n                        if (m.startStyle && sp.from == pos)\n                            spanStartStyle += ' ' + m.startStyle;\n                        if (m.endStyle && sp.to == nextChange)\n                            (endStyles || (endStyles = [])).push(m.endStyle, sp.to);\n                        if (m.title)\n                            (attributes || (attributes = {})).title = m.title;\n                        if (m.attributes) {\n                            for (let attr in m.attributes)\n                                (attributes || (attributes = {}))[attr] = m.attributes[attr];\n                        }\n                        if (m.collapsed && (!collapsed || h.compareCollapsedMarkers(collapsed.marker, m) < 0))\n                            collapsed = sp;\n                    } else if (sp.from > pos && nextChange > sp.from) {\n                        nextChange = sp.from;\n                    }\n                }\n                if (endStyles)\n                    for (let j = 0; j < endStyles.length; j += 2)\n                        if (endStyles[j + 1] == nextChange)\n                            spanEndStyle += ' ' + endStyles[j];\n                if (!collapsed || collapsed.from == pos)\n                    for (let j = 0; j < foundBookmarks.length; ++j)\n                        buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n                if (collapsed && (collapsed.from || 0) == pos) {\n                    buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n                    if (collapsed.to == null)\n                        return;\n                    if (collapsed.to == pos)\n                        collapsed = false;\n                }\n            }\n            if (pos >= len)\n                break;\n            let upto = Math.min(len, nextChange);\n            while (true) {\n                if (text) {\n                    let end = pos + text.length;\n                    if (!collapsed) {\n                        let tokenText = end > upto ? text.slice(0, upto - pos) : text;\n                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', css, attributes);\n                    }\n                    if (end >= upto) {\n                        text = text.slice(upto - pos);\n                        pos = upto;\n                        break;\n                    }\n                    pos = end;\n                    spanStartStyle = '';\n                }\n                text = allText.slice(at, at = styles[i++]);\n                style = interpretTokenStyle(styles[i++], builder.cm.options);\n            }\n        }\n    }\n    function LineView(doc, line, lineN) {\n        this.line = line;\n        this.rest = h.visualLineContinued(line);\n        this.size = this.rest ? m_utils_line.lineNo(f.lst(this.rest)) - lineN + 1 : 1;\n        this.node = this.text = null;\n        this.hidden = h.lineIsHidden(doc, line);\n    }\n    function buildViewArray(cm, from, to) {\n        let array = [], nextPos;\n        for (let pos = from; pos < to; pos = nextPos) {\n            let view = new LineView(cm.doc, m_utils_line.getLine(cm.doc, pos), pos);\n            nextPos = pos + view.size;\n            array.push(view);\n        }\n        return array;\n    }\n    return {\n        Line: Line,\n        updateLine: updateLine,\n        cleanUpLine: cleanUpLine,\n        buildLineContent: buildLineContent,\n        defaultSpecialCharPlaceholder: defaultSpecialCharPlaceholder,\n        LineView: LineView,\n        buildViewArray: buildViewArray\n    };\n});"]}