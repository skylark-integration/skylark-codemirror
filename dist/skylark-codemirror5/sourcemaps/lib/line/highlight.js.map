{"version":3,"sources":["lib/line/highlight.js"],"names":["define","a","b","StringStream","c","d","SavedContext","[object Object]","state","lookAhead","this","Context","doc","line","maxLookAhead","baseTokens","baseTokenPos","n","undefined","type","replace","size","saved","copyState","mode","copy","highlightLine","cm","context","forceToEnd","st","modeGen","lineClasses","runMode","text","end","style","push","o","overlays","length","overlay","i","at","start","i_end","splice","Math","min","opaque","cur","styles","classes","bgClass","textClass","getContextBefore","precise","display","minindent","minline","lim","search","first","getLine","after","stateAfter","modeFrontier","indented","countColumn","options","tabSize","findStartLine","fromSaved","startState","iter","processLine","pos","viewFrom","viewTo","save","nextLine","startAt","stream","callBlankLine","eol","readToken","blankLine","inner","innerMode","token","Error","name","Token","string","current","extractLineClasses","output","lineClass","match","slice","index","prop","RegExp","test","f","flattenSpans","curStart","curStyle","addModeClass","maxHighlightLength","mName","getLineStyles","updateFrontier","lineNo","resetState","result","styleClasses","highlightFrontier","max","takeToken","asArray","clipPos","tokens","ch","retreatFrontier"],"mappings":";;;;;;;AAAAA,QACI,eACA,WACA,uBACA,eACA,SACD,SAAUC,EAAGC,EAAGC,EAAcC,EAAGC,GAChC,mBACMC,EACFC,YAAYC,EAAOC,GACfC,KAAKF,MAAQA,EACbE,KAAKD,UAAYA,SAGnBE,EACFJ,YAAYK,EAAKJ,EAAOK,EAAMJ,GAC1BC,KAAKF,MAAQA,EACbE,KAAKE,IAAMA,EACXF,KAAKG,KAAOA,EACZH,KAAKI,aAAeL,GAAa,EACjCC,KAAKK,WAAa,KAClBL,KAAKM,aAAe,EAExBT,UAAUU,GACN,IAAIJ,EAAOH,KAAKE,IAAIM,UAAUR,KAAKG,KAAOI,GAG1C,OAFY,MAARJ,GAAgBI,EAAIP,KAAKI,eACzBJ,KAAKI,aAAeG,GACjBJ,EAEXN,UAAUU,GACN,IAAKP,KAAKK,WACN,OAAO,KACX,KAAOL,KAAKK,WAAWL,KAAKM,eAAiBC,GACzCP,KAAKM,cAAgB,EACzB,IAAIG,EAAOT,KAAKK,WAAWL,KAAKM,aAAe,GAC/C,OACIG,KAAMA,GAAQA,EAAKC,QAAQ,kBAAmB,IAC9CC,KAAMX,KAAKK,WAAWL,KAAKM,cAAgBC,GAGnDV,WACIG,KAAKG,OACDH,KAAKI,aAAe,GACpBJ,KAAKI,eAEbP,iBAAiBK,EAAKU,EAAOT,GACzB,OAAIS,aAAiBhB,EACV,IAAIK,EAAQC,EAAKV,EAAEqB,UAAUX,EAAIY,KAAMF,EAAMd,OAAQK,EAAMS,EAAMb,WAEjE,IAAIE,EAAQC,EAAKV,EAAEqB,UAAUX,EAAIY,KAAMF,GAAQT,GAE9DN,KAAKkB,GACD,IAAIjB,GAAiB,IAATiB,EAAiBvB,EAAEqB,UAAUb,KAAKE,IAAIY,KAAMd,KAAKF,OAASE,KAAKF,MAC3E,OAAOE,KAAKI,aAAe,EAAI,IAAIR,EAAaE,EAAOE,KAAKI,cAAgBN,GAGpF,SAASkB,EAAcC,EAAId,EAAMe,EAASC,GACtC,IAAIC,GAAMH,EAAGnB,MAAMuB,SAAUC,KAC7BC,EAAQN,EAAId,EAAKqB,KAAMP,EAAGf,IAAIY,KAAMI,EAAS,CAACO,EAAKC,IAAUN,EAAGO,KAAKF,EAAKC,GAAQJ,EAAaH,GAC/F,IAAIrB,EAAQoB,EAAQpB,MACpB,IAAK,IAAI8B,EAAI,EAAGA,EAAIX,EAAGnB,MAAM+B,SAASC,SAAUF,EAAG,CAC/CV,EAAQb,WAAae,EACrB,IAAIW,EAAUd,EAAGnB,MAAM+B,SAASD,GAAII,EAAI,EAAGC,EAAK,EAChDf,EAAQpB,OAAQ,EAChByB,EAAQN,EAAId,EAAKqB,KAAMO,EAAQjB,KAAMI,EAAS,CAACO,EAAKC,KAChD,IAAIQ,EAAQF,EACZ,KAAOC,EAAKR,GAAK,CACb,IAAIU,EAAQf,EAAGY,GACXG,EAAQV,GACRL,EAAGgB,OAAOJ,EAAG,EAAGP,EAAKL,EAAGY,EAAI,GAAIG,GACpCH,GAAK,EACLC,EAAKI,KAAKC,IAAIb,EAAKU,GAEvB,GAAKT,EAEL,GAAIK,EAAQQ,OACRnB,EAAGgB,OAAOF,EAAOF,EAAIE,EAAOT,EAAK,WAAaC,GAC9CM,EAAIE,EAAQ,OAEZ,KAAOA,EAAQF,EAAGE,GAAS,EAAG,CAC1B,IAAIM,EAAMpB,EAAGc,EAAQ,GACrBd,EAAGc,EAAQ,IAAMM,EAAMA,EAAM,IAAM,IAAM,WAAad,IAG/DJ,GACHJ,EAAQpB,MAAQA,EAChBoB,EAAQb,WAAa,KACrBa,EAAQZ,aAAe,EAE3B,OACImC,OAAQrB,EACRsB,QAASpB,EAAYqB,SAAWrB,EAAYsB,UAAYtB,EAAc,MAqB9E,SAASuB,EAAiB5B,EAAIV,EAAGuC,GAC7B,IAAI5C,EAAMe,EAAGf,IAAK6C,EAAU9B,EAAG8B,QAC/B,IAAK7C,EAAIY,KAAKN,UACV,OAAO,IAAIP,EAAQC,GAAK,EAAMK,GAClC,IAAI2B,EAyHR,SAAuBjB,EAAIV,EAAGuC,GAC1B,IAAIE,EAAWC,EAAS/C,EAAMe,EAAGf,IAC7BgD,EAAMJ,GAAW,EAAIvC,GAAKU,EAAGf,IAAIY,KAAKN,UAAY,IAAO,KAC7D,IAAK,IAAI2C,EAAS5C,EAAG4C,EAASD,IAAOC,EAAQ,CACzC,GAAIA,GAAUjD,EAAIkD,MACd,OAAOlD,EAAIkD,MACf,IAAIjD,EAAOT,EAAE2D,QAAQnD,EAAKiD,EAAS,GAAIG,EAAQnD,EAAKoD,WACpD,GAAID,KAAWR,GAAWK,GAAUG,aAAiB1D,EAAe0D,EAAMvD,UAAY,IAAMG,EAAIsD,cAC5F,OAAOL,EACX,IAAIM,EAAWlE,EAAEmE,YAAYvD,EAAKqB,KAAM,KAAMP,EAAG0C,QAAQC,UAC1C,MAAXX,GAAmBD,EAAYS,KAC/BR,EAAUE,EAAS,EACnBH,EAAYS,GAGpB,OAAOR,EAxIKY,CAAc5C,EAAIV,EAAGuC,GAC7BlC,EAAQsB,EAAQhC,EAAIkD,OAAS1D,EAAE2D,QAAQnD,EAAKgC,EAAQ,GAAGqB,WACvDrC,EAAUN,EAAQX,EAAQ6D,UAAU5D,EAAKU,EAAOsB,GAAS,IAAIjC,EAAQC,EAAKV,EAAEuE,WAAW7D,EAAIY,MAAOoB,GAStG,OARAhC,EAAI8D,KAAK9B,EAAO3B,EAAGJ,IACf8D,EAAYhD,EAAId,EAAKqB,KAAMN,GAC3B,IAAIgD,EAAMhD,EAAQf,KAClBA,EAAKoD,WAAaW,GAAO3D,EAAI,GAAK2D,EAAM,GAAK,GAAKA,GAAOnB,EAAQoB,UAAYD,EAAMnB,EAAQqB,OAASlD,EAAQmD,OAAS,KACrHnD,EAAQoD,aAERxB,IACA5C,EAAIsD,aAAetC,EAAQf,MACxBe,EAEX,SAAS+C,EAAYhD,EAAIO,EAAMN,EAASqD,GACpC,IAAIzD,EAAOG,EAAGf,IAAIY,KACd0D,EAAS,IAAI/E,EAAa+B,EAAMP,EAAG0C,QAAQC,QAAS1C,GAIxD,IAHAsD,EAAOtC,MAAQsC,EAAON,IAAMK,GAAW,EAC3B,IAAR/C,GACAiD,EAAc3D,EAAMI,EAAQpB,QACxB0E,EAAOE,OACXC,EAAU7D,EAAM0D,EAAQtD,EAAQpB,OAChC0E,EAAOtC,MAAQsC,EAAON,IAG9B,SAASO,EAAc3D,EAAMhB,GACzB,GAAIgB,EAAK8D,UACL,OAAO9D,EAAK8D,UAAU9E,GAC1B,IAAKgB,EAAKN,UACN,OACJ,IAAIqE,EAAQrF,EAAEsF,UAAUhE,EAAMhB,GAC9B,OAAI+E,EAAM/D,KAAK8D,UACJC,EAAM/D,KAAK8D,UAAUC,EAAM/E,YADtC,EAGJ,SAAS6E,EAAU7D,EAAM0D,EAAQ1E,EAAO+E,GACpC,IAAK,IAAI7C,EAAI,EAAGA,EAAI,GAAIA,IAAK,CACrB6C,IACAA,EAAM,GAAKrF,EAAEsF,UAAUhE,EAAMhB,GAAOgB,MACxC,IAAIY,EAAQZ,EAAKiE,MAAMP,EAAQ1E,GAC/B,GAAI0E,EAAON,IAAMM,EAAOtC,MACpB,OAAOR,EAEf,MAAM,IAAIsD,MAAM,QAAUlE,EAAKmE,KAAO,oCAEpCC,EACFrF,YAAY2E,EAAQ/D,EAAMX,GACtBE,KAAKkC,MAAQsC,EAAOtC,MACpBlC,KAAKyB,IAAM+C,EAAON,IAClBlE,KAAKmF,OAASX,EAAOY,UACrBpF,KAAKS,KAAOA,GAAQ,KACpBT,KAAKF,MAAQA,GAkBrB,SAASuF,EAAmB5E,EAAM6E,GAC9B,GAAI7E,EACA,OAAS,CACL,IAAI8E,EAAY9E,EAAK+E,MAAM,qCAC3B,IAAKD,EACD,MACJ9E,EAAOA,EAAKgF,MAAM,EAAGF,EAAUG,OAASjF,EAAKgF,MAAMF,EAAUG,MAAQH,EAAU,GAAGzD,QAClF,IAAI6D,EAAOJ,EAAU,GAAK,UAAY,YAClB,MAAhBD,EAAOK,GACPL,EAAOK,GAAQJ,EAAU,GACnB,IAAIK,OAAO,UAAYL,EAAU,GAAK,WAAWM,KAAKP,EAAOK,MACnEL,EAAOK,IAAS,IAAMJ,EAAU,IAE5C,OAAO9E,EAEX,SAASc,EAAQN,EAAIO,EAAMV,EAAMI,EAAS4E,EAAGxE,EAAaH,GACtD,IAAI4E,EAAejF,EAAKiF,aACJ,MAAhBA,IACAA,EAAe9E,EAAG0C,QAAQoC,cAC9B,IACkErE,EAD9DsE,EAAW,EAAGC,EAAW,KACzBzB,EAAS,IAAI/E,EAAa+B,EAAMP,EAAG0C,QAAQC,QAAS1C,GACpD2D,EAAQ5D,EAAG0C,QAAQuC,eAAiB,MAGxC,IAFY,IAAR1E,GACA6D,EAAmBZ,EAAc3D,EAAMI,EAAQpB,OAAQwB,IACnDkD,EAAOE,OAAO,CAUlB,GATIF,EAAON,IAAMjD,EAAG0C,QAAQwC,oBACxBJ,GAAe,EACX5E,GACA8C,EAAYhD,EAAIO,EAAMN,EAASsD,EAAON,KAC1CM,EAAON,IAAM1C,EAAKM,OAClBJ,EAAQ,MAERA,EAAQ2D,EAAmBV,EAAU7D,EAAM0D,EAAQtD,EAAQpB,MAAO+E,GAAQvD,GAE1EuD,EAAO,CACP,IAAIuB,EAAQvB,EAAM,GAAGI,KACjBmB,IACA1E,EAAQ,MAAQA,EAAQ0E,EAAQ,IAAM1E,EAAQ0E,IAEtD,IAAKL,GAAgBE,GAAYvE,EAAO,CACpC,KAAOsE,EAAWxB,EAAOtC,OAErB4D,EADAE,EAAW3D,KAAKC,IAAIkC,EAAOtC,MAAO8D,EAAW,KACjCC,GAEhBA,EAAWvE,EAEf8C,EAAOtC,MAAQsC,EAAON,IAE1B,KAAO8B,EAAWxB,EAAON,KAAK,CAC1B,IAAIA,EAAM7B,KAAKC,IAAIkC,EAAON,IAAK8B,EAAW,KAC1CF,EAAE5B,EAAK+B,GACPD,EAAW9B,GAkCnB,OACIlD,cAAeA,EACfqF,cAhLJ,SAAuBpF,EAAId,EAAMmG,GAC7B,IAAKnG,EAAKsC,QAAUtC,EAAKsC,OAAO,IAAMxB,EAAGnB,MAAMuB,QAAS,CACpD,IAAIH,EAAU2B,EAAiB5B,EAAIvB,EAAE6G,OAAOpG,IACxCqG,EAAarG,EAAKqB,KAAKM,OAASb,EAAG0C,QAAQwC,oBAAsB3G,EAAEqB,UAAUI,EAAGf,IAAIY,KAAMI,EAAQpB,OAClG2G,EAASzF,EAAcC,EAAId,EAAMe,GACjCsF,IACAtF,EAAQpB,MAAQ0G,GACpBrG,EAAKoD,WAAarC,EAAQmD,MAAMmC,GAChCrG,EAAKsC,OAASgE,EAAOhE,OACjBgE,EAAO/D,QACPvC,EAAKuG,aAAeD,EAAO/D,QACtBvC,EAAKuG,eACVvG,EAAKuG,aAAe,MACpBJ,IAAmBrF,EAAGf,IAAIyG,oBAC1B1F,EAAGf,IAAIsD,aAAenB,KAAKuE,IAAI3F,EAAGf,IAAIsD,eAAgBvC,EAAGf,IAAIyG,oBAErE,OAAOxG,EAAKsC,QAiKZI,iBAAkBA,EAClBoB,YAAaA,EACb4C,UAzGJ,SAAmB5F,EAAIiD,EAAKpB,EAASgE,GACjC,IAAmCpF,EAA/BxB,EAAMe,EAAGf,IAAKY,EAAOZ,EAAIY,KAC7BoD,EAAMvE,EAAEoH,QAAQ7G,EAAKgE,GACrB,IACuE8C,EADnE7G,EAAOT,EAAE2D,QAAQnD,EAAKgE,EAAI/D,MAAOe,EAAU2B,EAAiB5B,EAAIiD,EAAI/D,KAAM2C,GAC1E0B,EAAS,IAAI/E,EAAaU,EAAKqB,KAAMP,EAAG0C,QAAQC,QAAS1C,GAG7D,IAFI4F,IACAE,OACIF,GAAWtC,EAAON,IAAMA,EAAI+C,MAAQzC,EAAOE,OAC/CF,EAAOtC,MAAQsC,EAAON,IACtBxC,EAAQiD,EAAU7D,EAAM0D,EAAQtD,EAAQpB,OACpCgH,GACAE,EAAOrF,KAAK,IAAIuD,EAAMV,EAAQ9C,EAAOlC,EAAEqB,UAAUX,EAAIY,KAAMI,EAAQpB,SAE3E,OAAOgH,EAAUE,EAAS,IAAI9B,EAAMV,EAAQ9C,EAAOR,EAAQpB,QA6F3DoH,gBApBJ,SAAyBhH,EAAKK,GAE1B,GADAL,EAAIsD,aAAenB,KAAKC,IAAIpC,EAAIsD,aAAcjD,GAC1CL,EAAIyG,kBAAoBpG,EAAI,GAC5B,OACJ,IAAI2B,EAAQhC,EAAIkD,MAChB,IAAK,IAAIjD,EAAOI,EAAI,EAAGJ,EAAO+B,EAAO/B,IAAQ,CACzC,IAAIS,EAAQlB,EAAE2D,QAAQnD,EAAKC,GAAMoD,WACjC,GAAI3C,MAAYA,aAAiBhB,IAAiBO,EAAOS,EAAMb,UAAYQ,GAAI,CAC3E2B,EAAQ/B,EAAO,EACf,OAGRD,EAAIyG,kBAAoBtE,KAAKC,IAAIpC,EAAIyG,kBAAmBzE","file":"../../../lib/line/highlight.js","sourcesContent":["define([\n    '../util/misc',\n    '../modes',\n    '../util/StringStream',\n    './utils_line',\n    './pos'\n], function (a, b, StringStream, c, d) {\n    'use strict';\n    class SavedContext {\n        constructor(state, lookAhead) {\n            this.state = state;\n            this.lookAhead = lookAhead;\n        }\n    }\n    class Context {\n        constructor(doc, state, line, lookAhead) {\n            this.state = state;\n            this.doc = doc;\n            this.line = line;\n            this.maxLookAhead = lookAhead || 0;\n            this.baseTokens = null;\n            this.baseTokenPos = 1;\n        }\n        lookAhead(n) {\n            let line = this.doc.undefined(this.line + n);\n            if (line != null && n > this.maxLookAhead)\n                this.maxLookAhead = n;\n            return line;\n        }\n        baseToken(n) {\n            if (!this.baseTokens)\n                return null;\n            while (this.baseTokens[this.baseTokenPos] <= n)\n                this.baseTokenPos += 2;\n            let type = this.baseTokens[this.baseTokenPos + 1];\n            return {\n                type: type && type.replace(/( |^)overlay .*/, ''),\n                size: this.baseTokens[this.baseTokenPos] - n\n            };\n        }\n        nextLine() {\n            this.line++;\n            if (this.maxLookAhead > 0)\n                this.maxLookAhead--;\n        }\n        static fromSaved(doc, saved, line) {\n            if (saved instanceof SavedContext)\n                return new Context(doc, b.copyState(doc.mode, saved.state), line, saved.lookAhead);\n            else\n                return new Context(doc, b.copyState(doc.mode, saved), line);\n        }\n        save(copy) {\n            let state = copy !== false ? b.copyState(this.doc.mode, this.state) : this.state;\n            return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n        }\n    }\n    function highlightLine(cm, line, context, forceToEnd) {\n        let st = [cm.state.modeGen], lineClasses = {};\n        runMode(cm, line.text, cm.doc.mode, context, (end, style) => st.push(end, style), lineClasses, forceToEnd);\n        let state = context.state;\n        for (let o = 0; o < cm.state.overlays.length; ++o) {\n            context.baseTokens = st;\n            let overlay = cm.state.overlays[o], i = 1, at = 0;\n            context.state = true;\n            runMode(cm, line.text, overlay.mode, context, (end, style) => {\n                let start = i;\n                while (at < end) {\n                    let i_end = st[i];\n                    if (i_end > end)\n                        st.splice(i, 1, end, st[i + 1], i_end);\n                    i += 2;\n                    at = Math.min(end, i_end);\n                }\n                if (!style)\n                    return;\n                if (overlay.opaque) {\n                    st.splice(start, i - start, end, 'overlay ' + style);\n                    i = start + 2;\n                } else {\n                    for (; start < i; start += 2) {\n                        let cur = st[start + 1];\n                        st[start + 1] = (cur ? cur + ' ' : '') + 'overlay ' + style;\n                    }\n                }\n            }, lineClasses);\n            context.state = state;\n            context.baseTokens = null;\n            context.baseTokenPos = 1;\n        }\n        return {\n            styles: st,\n            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null\n        };\n    }\n    function getLineStyles(cm, line, updateFrontier) {\n        if (!line.styles || line.styles[0] != cm.state.modeGen) {\n            let context = getContextBefore(cm, c.lineNo(line));\n            let resetState = line.text.length > cm.options.maxHighlightLength && b.copyState(cm.doc.mode, context.state);\n            let result = highlightLine(cm, line, context);\n            if (resetState)\n                context.state = resetState;\n            line.stateAfter = context.save(!resetState);\n            line.styles = result.styles;\n            if (result.classes)\n                line.styleClasses = result.classes;\n            else if (line.styleClasses)\n                line.styleClasses = null;\n            if (updateFrontier === cm.doc.highlightFrontier)\n                cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n        }\n        return line.styles;\n    }\n    function getContextBefore(cm, n, precise) {\n        let doc = cm.doc, display = cm.display;\n        if (!doc.mode.undefined)\n            return new Context(doc, true, n);\n        let start = findStartLine(cm, n, precise);\n        let saved = start > doc.first && c.getLine(doc, start - 1).stateAfter;\n        let context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, b.startState(doc.mode), start);\n        doc.iter(start, n, line => {\n            processLine(cm, line.text, context);\n            let pos = context.line;\n            line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n            context.nextLine();\n        });\n        if (precise)\n            doc.modeFrontier = context.line;\n        return context;\n    }\n    function processLine(cm, text, context, startAt) {\n        let mode = cm.doc.mode;\n        let stream = new StringStream(text, cm.options.tabSize, context);\n        stream.start = stream.pos = startAt || 0;\n        if (text == '')\n            callBlankLine(mode, context.state);\n        while (!stream.eol()) {\n            readToken(mode, stream, context.state);\n            stream.start = stream.pos;\n        }\n    }\n    function callBlankLine(mode, state) {\n        if (mode.blankLine)\n            return mode.blankLine(state);\n        if (!mode.undefined)\n            return;\n        let inner = b.innerMode(mode, state);\n        if (inner.mode.blankLine)\n            return inner.mode.blankLine(inner.state);\n    }\n    function readToken(mode, stream, state, inner) {\n        for (let i = 0; i < 10; i++) {\n            if (inner)\n                inner[0] = b.innerMode(mode, state).mode;\n            let style = mode.token(stream, state);\n            if (stream.pos > stream.start)\n                return style;\n        }\n        throw new Error('Mode ' + mode.name + ' failed to advance stream.');\n    }\n    class Token {\n        constructor(stream, type, state) {\n            this.start = stream.start;\n            this.end = stream.pos;\n            this.string = stream.current();\n            this.type = type || null;\n            this.state = state;\n        }\n    }\n    function takeToken(cm, pos, precise, asArray) {\n        let doc = cm.doc, mode = doc.mode, style;\n        pos = d.clipPos(doc, pos);\n        let line = c.getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n        let stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n        if (asArray)\n            tokens = [];\n        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n            stream.start = stream.pos;\n            style = readToken(mode, stream, context.state);\n            if (asArray)\n                tokens.push(new Token(stream, style, b.copyState(doc.mode, context.state)));\n        }\n        return asArray ? tokens : new Token(stream, style, context.state);\n    }\n    function extractLineClasses(type, output) {\n        if (type)\n            for (;;) {\n                let lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n                if (!lineClass)\n                    break;\n                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n                let prop = lineClass[1] ? 'bgClass' : 'textClass';\n                if (output[prop] == null)\n                    output[prop] = lineClass[2];\n                else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(output[prop]))\n                    output[prop] += ' ' + lineClass[2];\n            }\n        return type;\n    }\n    function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n        let flattenSpans = mode.flattenSpans;\n        if (flattenSpans == null)\n            flattenSpans = cm.options.flattenSpans;\n        let curStart = 0, curStyle = null;\n        let stream = new StringStream(text, cm.options.tabSize, context), style;\n        let inner = cm.options.addModeClass && [null];\n        if (text == '')\n            extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n        while (!stream.eol()) {\n            if (stream.pos > cm.options.maxHighlightLength) {\n                flattenSpans = false;\n                if (forceToEnd)\n                    processLine(cm, text, context, stream.pos);\n                stream.pos = text.length;\n                style = null;\n            } else {\n                style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n            }\n            if (inner) {\n                let mName = inner[0].name;\n                if (mName)\n                    style = 'm-' + (style ? mName + ' ' + style : mName);\n            }\n            if (!flattenSpans || curStyle != style) {\n                while (curStart < stream.start) {\n                    curStart = Math.min(stream.start, curStart + 5000);\n                    f(curStart, curStyle);\n                }\n                curStyle = style;\n            }\n            stream.start = stream.pos;\n        }\n        while (curStart < stream.pos) {\n            let pos = Math.min(stream.pos, curStart + 5000);\n            f(pos, curStyle);\n            curStart = pos;\n        }\n    }\n    function findStartLine(cm, n, precise) {\n        let minindent, minline, doc = cm.doc;\n        let lim = precise ? -1 : n - (cm.doc.mode.undefined ? 1000 : 100);\n        for (let search = n; search > lim; --search) {\n            if (search <= doc.first)\n                return doc.first;\n            let line = c.getLine(doc, search - 1), after = line.stateAfter;\n            if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n                return search;\n            let indented = a.countColumn(line.text, null, cm.options.tabSize);\n            if (minline == null || minindent > indented) {\n                minline = search - 1;\n                minindent = indented;\n            }\n        }\n        return minline;\n    }\n    function retreatFrontier(doc, n) {\n        doc.modeFrontier = Math.min(doc.modeFrontier, n);\n        if (doc.highlightFrontier < n - 10)\n            return;\n        let start = doc.first;\n        for (let line = n - 1; line > start; line--) {\n            let saved = c.getLine(doc, line).stateAfter;\n            if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n                start = line + 1;\n                break;\n            }\n        }\n        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n    }\n    return {\n        highlightLine: highlightLine,\n        getLineStyles: getLineStyles,\n        getContextBefore: getContextBefore,\n        processLine: processLine,\n        takeToken: takeToken,\n        retreatFrontier: retreatFrontier\n    };\n});"]}