{"version":3,"sources":["primitives/measurement/position_measurement.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","paddingTop","display","lineSpace","offsetTop","paddingH","cachedPaddingH","removeChildrenAndAdd","measure","elt","style","window","getComputedStyle","currentStyle","data","left","parseInt","paddingLeft","right","paddingRight","isNaN","scrollGap","cm","scrollerGap","nativeBarWidth","displayWidth","scroller","clientWidth","barWidth","mapFromLineView","lineView","line","lineN","map","cache","rest","length","maps","caches","lineNo","before","measureChar","ch","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","viewFrom","viewTo","view","findViewIndex","ext","externalMeasured","size","text","changes","updateLineForChanges","getDimensions","curOp","forceUpdate","visualLine","LineView","doc","built","buildLineContent","pre","lineMeasure","updateExternalMeasurement","info","rect","hasHeights","prepared","varHeight","found","key","hasOwnProperty","getBoundingClientRect","wrapping","options","lineWrapping","curWidth","heights","width","rects","firstChild","getClientRects","cur","next","Math","abs","bottom","push","top","ensureLineHeights","place","nodeAndOffsetInLineMap","node","start","end","collapse","nodeType","isExtendingChar","charAt","coverStart","coverEnd","ie","ie_version","parentNode","getUsefulRect","range","maybeUpdateRectForZooming","rSpan","charWidth","nullRect","rtop","rbot","mid","bot","result","bogus","singleCursorHeightPerLine","rbottom","measureCharInner","measureText","mStart","mEnd","insertLeft","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","removeChildren","pageScrollX","chrome","android","document","body","marginLeft","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","lineObj","height","widgets","above","widgetHeight","intoCoordSystem","context","includeWidgets","yOff","heightAtLine","viewOffset","lOff","xOff","cursorCoords","pos","preparedMeasure","get","m","getLine","order","getOrder","direction","sticky","getBidi","partPos","invert","level","getBidiPartAt","other","bidiOther","val","PosWithInfo","outside","xRel","Pos","coordsChar","x","y","first","lineAtHeight","last","coordsCharInner","collapsed","collapsedSpanAround","rangeEnd","find","wrappedLineExtent","begin","findFirst","boxIsAfter","box","ltr","part","_lineNo","test","closestDist","p","from","to","endX","min","max","dist","index","baseX","chAround","boxAround","atLeft","atStart","coords","skipExtendingChars","textHeight","cachedTextHeight","appendChild","createTextNode","offsetHeight","cachedCharWidth","anchor","gutterLeft","gutters","clientLeft","n","nextSibling","offsetLeft","fixedPos","compensateForHScroll","gutterTotalWidth","offsetWidth","gutterWidth","wrapperWidth","wrapper","sizer","estimateHeight","th","perLine","lineIsHidden","widgetsHeight","ceil","paddingVert","mover","displayHeight","clientHeight","barHeight","clearCaches","maxLineChanged","lineNumChars","fromCoordSystem","localBox","lineSpaceBox","charCoords","estimateCoords","clipPos","wrappedLineExtentChar","target","estimateLineHeights","est","iter","estHeight","updateLineHeight","posFromMouse","liberal","forRect","e_target","getAttribute","space","clientX","clientY","colDiff","countColumn","tabSize","round"],"mappings":"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","file":"../../../primitives/measurement/position_measurement.js","sourcesContent":["define([\n    '../line/line_data',\n    '../line/pos',\n    '../line/spans',\n    '../line/utils_line',\n    '../util/bidi',\n    '../util/browser',\n    '../util/dom',\n    '../util/event',\n    '../util/feature_detection',\n    '../util/misc',\n    '../display/update_line',\n    './widgets'\n], function (a, b, c, d, e, f, g, h, i, j, k, l) {\n    'use strict';\n    function paddingTop(display) {\n        return display.lineSpace.offsetTop;\n    }\n    function paddingVert(display) {\n        return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n    }\n    function paddingH(display) {\n        if (display.cachedPaddingH)\n            return display.cachedPaddingH;\n        let e = g.removeChildrenAndAdd(display.measure, g.elt('pre', 'x'));\n        let style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n        let data = {\n            left: parseInt(style.paddingLeft),\n            right: parseInt(style.paddingRight)\n        };\n        if (!isNaN(data.left) && !isNaN(data.right))\n            display.cachedPaddingH = data;\n        return data;\n    }\n    function scrollGap(cm) {\n        return j.scrollerGap - cm.display.nativeBarWidth;\n    }\n    function displayWidth(cm) {\n        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n    }\n    function displayHeight(cm) {\n        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n    }\n    function ensureLineHeights(cm, lineView, rect) {\n        let wrapping = cm.options.lineWrapping;\n        let curWidth = wrapping && displayWidth(cm);\n        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n            let heights = lineView.measure.heights = [];\n            if (wrapping) {\n                lineView.measure.width = curWidth;\n                let rects = lineView.text.firstChild.getClientRects();\n                for (let i = 0; i < rects.length - 1; i++) {\n                    let cur = rects[i], next = rects[i + 1];\n                    if (Math.abs(cur.bottom - next.bottom) > 2)\n                        heights.push((cur.bottom + next.top) / 2 - rect.top);\n                }\n            }\n            heights.push(rect.bottom - rect.top);\n        }\n    }\n    function mapFromLineView(lineView, line, lineN) {\n        if (lineView.line == line)\n            return {\n                map: lineView.measure.map,\n                cache: lineView.measure.cache\n            };\n        for (let i = 0; i < lineView.rest.length; i++)\n            if (lineView.rest[i] == line)\n                return {\n                    map: lineView.measure.maps[i],\n                    cache: lineView.measure.caches[i]\n                };\n        for (let i = 0; i < lineView.rest.length; i++)\n            if (d.lineNo(lineView.rest[i]) > lineN)\n                return {\n                    map: lineView.measure.maps[i],\n                    cache: lineView.measure.caches[i],\n                    before: true\n                };\n    }\n    function updateExternalMeasurement(cm, line) {\n        line = c.visualLine(line);\n        let lineN = d.lineNo(line);\n        let view = cm.display.externalMeasured = new a.LineView(cm.doc, line, lineN);\n        view.lineN = lineN;\n        let built = view.built = a.buildLineContent(cm, view);\n        view.text = built.pre;\n        g.removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n        return view;\n    }\n    function measureChar(cm, line, ch, bias) {\n        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n    }\n    function findViewForLine(cm, lineN) {\n        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n            return cm.display.view[findViewIndex(cm, lineN)];\n        let ext = cm.display.externalMeasured;\n        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n            return ext;\n    }\n    function prepareMeasureForLine(cm, line) {\n        let lineN = d.lineNo(line);\n        let view = findViewForLine(cm, lineN);\n        if (view && !view.text) {\n            view = null;\n        } else if (view && view.changes) {\n            k.updateLineForChanges(cm, view, lineN, getDimensions(cm));\n            cm.curOp.forceUpdate = true;\n        }\n        if (!view)\n            view = updateExternalMeasurement(cm, line);\n        let info = mapFromLineView(view, line, lineN);\n        return {\n            line: line,\n            view: view,\n            rect: null,\n            map: info.map,\n            cache: info.cache,\n            before: info.before,\n            hasHeights: false\n        };\n    }\n    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n        if (prepared.before)\n            ch = -1;\n        let key = ch + (bias || ''), found;\n        if (prepared.cache.hasOwnProperty(key)) {\n            found = prepared.cache[key];\n        } else {\n            if (!prepared.rect)\n                prepared.rect = prepared.view.text.getBoundingClientRect();\n            if (!prepared.hasHeights) {\n                ensureLineHeights(cm, prepared.view, prepared.rect);\n                prepared.hasHeights = true;\n            }\n            found = measureCharInner(cm, prepared, ch, bias);\n            if (!found.bogus)\n                prepared.cache[key] = found;\n        }\n        return {\n            left: found.left,\n            right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom\n        };\n    }\n    let nullRect = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    function nodeAndOffsetInLineMap(map, ch, bias) {\n        let node, start, end, collapse, mStart, mEnd;\n        for (let i = 0; i < map.length; i += 3) {\n            mStart = map[i];\n            mEnd = map[i + 1];\n            if (ch < mStart) {\n                start = 0;\n                end = 1;\n                collapse = 'left';\n            } else if (ch < mEnd) {\n                start = ch - mStart;\n                end = start + 1;\n            } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n                end = mEnd - mStart;\n                start = end - 1;\n                if (ch >= mEnd)\n                    collapse = 'right';\n            }\n            if (start != null) {\n                node = map[i + 2];\n                if (mStart == mEnd && bias == (node.insertLeft ? 'left' : 'right'))\n                    collapse = bias;\n                if (bias == 'left' && start == 0)\n                    while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n                        node = map[(i -= 3) + 2];\n                        collapse = 'left';\n                    }\n                if (bias == 'right' && start == mEnd - mStart)\n                    while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n                        node = map[(i += 3) + 2];\n                        collapse = 'right';\n                    }\n                break;\n            }\n        }\n        return {\n            node: node,\n            start: start,\n            end: end,\n            collapse: collapse,\n            coverStart: mStart,\n            coverEnd: mEnd\n        };\n    }\n    function getUsefulRect(rects, bias) {\n        let rect = nullRect;\n        if (bias == 'left')\n            for (let i = 0; i < rects.length; i++) {\n                if ((rect = rects[i]).left != rect.right)\n                    break;\n            }\n        else\n            for (let i = rects.length - 1; i >= 0; i--) {\n                if ((rect = rects[i]).left != rect.right)\n                    break;\n            }\n        return rect;\n    }\n    function measureCharInner(cm, prepared, ch, bias) {\n        let place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n        let node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n        let rect;\n        if (node.nodeType == 3) {\n            for (let i = 0; i < 4; i++) {\n                while (start && j.isExtendingChar(prepared.line.text.charAt(place.coverStart + start)))\n                    --start;\n                while (place.coverStart + end < place.coverEnd && j.isExtendingChar(prepared.line.text.charAt(place.coverStart + end)))\n                    ++end;\n                if (f.ie && f.ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n                    rect = node.parentNode.getBoundingClientRect();\n                else\n                    rect = getUsefulRect(g.range(node, start, end).getClientRects(), bias);\n                if (rect.left || rect.right || start == 0)\n                    break;\n                end = start;\n                start = start - 1;\n                collapse = 'right';\n            }\n            if (f.ie && f.ie_version < 11)\n                rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n        } else {\n            if (start > 0)\n                collapse = bias = 'right';\n            let rects;\n            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n                rect = rects[bias == 'right' ? rects.length - 1 : 0];\n            else\n                rect = node.getBoundingClientRect();\n        }\n        if (f.ie && f.ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n            let rSpan = node.parentNode.getClientRects()[0];\n            if (rSpan)\n                rect = {\n                    left: rSpan.left,\n                    right: rSpan.left + charWidth(cm.display),\n                    top: rSpan.top,\n                    bottom: rSpan.bottom\n                };\n            else\n                rect = nullRect;\n        }\n        let rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n        let mid = (rtop + rbot) / 2;\n        let heights = prepared.view.measure.heights;\n        let i = 0;\n        for (; i < heights.length - 1; i++)\n            if (mid < heights[i])\n                break;\n        let top = i ? heights[i - 1] : 0, bot = heights[i];\n        let result = {\n            left: (collapse == 'right' ? rect.right : rect.left) - prepared.rect.left,\n            right: (collapse == 'left' ? rect.left : rect.right) - prepared.rect.left,\n            top: top,\n            bottom: bot\n        };\n        if (!rect.left && !rect.right)\n            result.bogus = true;\n        if (!cm.options.singleCursorHeightPerLine) {\n            result.rtop = rtop;\n            result.rbottom = rbot;\n        }\n        return result;\n    }\n    function maybeUpdateRectForZooming(measure, rect) {\n        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !i.hasBadZoomedRects(measure))\n            return rect;\n        let scaleX = screen.logicalXDPI / screen.deviceXDPI;\n        let scaleY = screen.logicalYDPI / screen.deviceYDPI;\n        return {\n            left: rect.left * scaleX,\n            right: rect.right * scaleX,\n            top: rect.top * scaleY,\n            bottom: rect.bottom * scaleY\n        };\n    }\n    function clearLineMeasurementCacheFor(lineView) {\n        if (lineView.measure) {\n            lineView.measure.cache = {};\n            lineView.measure.heights = null;\n            if (lineView.rest)\n                for (let i = 0; i < lineView.rest.length; i++)\n                    lineView.measure.caches[i] = {};\n        }\n    }\n    function clearLineMeasurementCache(cm) {\n        cm.display.externalMeasure = null;\n        g.removeChildren(cm.display.lineMeasure);\n        for (let i = 0; i < cm.display.view.length; i++)\n            clearLineMeasurementCacheFor(cm.display.view[i]);\n    }\n    function clearCaches(cm) {\n        clearLineMeasurementCache(cm);\n        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n        if (!cm.options.lineWrapping)\n            cm.display.maxLineChanged = true;\n        cm.display.lineNumChars = null;\n    }\n    function pageScrollX() {\n        if (f.chrome && f.android)\n            return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));\n        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n    }\n    function pageScrollY() {\n        if (f.chrome && f.android)\n            return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));\n        return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n    }\n    function widgetTopHeight(lineObj) {\n        let height = 0;\n        if (lineObj.widgets)\n            for (let i = 0; i < lineObj.widgets.length; ++i)\n                if (lineObj.widgets[i].above)\n                    height += l.widgetHeight(lineObj.widgets[i]);\n        return height;\n    }\n    function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n        if (!includeWidgets) {\n            let height = widgetTopHeight(lineObj);\n            rect.top += height;\n            rect.bottom += height;\n        }\n        if (context == 'line')\n            return rect;\n        if (!context)\n            context = 'local';\n        let yOff = c.heightAtLine(lineObj);\n        if (context == 'local')\n            yOff += paddingTop(cm.display);\n        else\n            yOff -= cm.display.viewOffset;\n        if (context == 'page' || context == 'window') {\n            let lOff = cm.display.lineSpace.getBoundingClientRect();\n            yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());\n            let xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());\n            rect.left += xOff;\n            rect.right += xOff;\n        }\n        rect.top += yOff;\n        rect.bottom += yOff;\n        return rect;\n    }\n    function fromCoordSystem(cm, coords, context) {\n        if (context == 'div')\n            return coords;\n        let left = coords.left, top = coords.top;\n        if (context == 'page') {\n            left -= pageScrollX();\n            top -= pageScrollY();\n        } else if (context == 'local' || !context) {\n            let localBox = cm.display.sizer.getBoundingClientRect();\n            left += localBox.left;\n            top += localBox.top;\n        }\n        let lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n        return {\n            left: left - lineSpaceBox.left,\n            top: top - lineSpaceBox.top\n        };\n    }\n    function charCoords(cm, pos, context, lineObj, bias) {\n        if (!lineObj)\n            lineObj = d.getLine(cm.doc, pos.line);\n        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n    }\n    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n        lineObj = lineObj || d.getLine(cm.doc, pos.line);\n        if (!preparedMeasure)\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        function get(ch, right) {\n            let m = measureCharPrepared(cm, preparedMeasure, ch, right ? 'right' : 'left', varHeight);\n            if (right)\n                m.left = m.right;\n            else\n                m.right = m.left;\n            return intoCoordSystem(cm, lineObj, m, context);\n        }\n        let order = e.getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n        if (ch >= lineObj.text.length) {\n            ch = lineObj.text.length;\n            sticky = 'before';\n        } else if (ch <= 0) {\n            ch = 0;\n            sticky = 'after';\n        }\n        if (!order)\n            return get(sticky == 'before' ? ch - 1 : ch, sticky == 'before');\n        function getBidi(ch, partPos, invert) {\n            let part = order[partPos], right = part.level == 1;\n            return get(invert ? ch - 1 : ch, right != invert);\n        }\n        let partPos = e.getBidiPartAt(order, ch, sticky);\n        let other = e.bidiOther;\n        let val = getBidi(ch, partPos, sticky == 'before');\n        if (other != null)\n            val.other = getBidi(ch, other, sticky != 'before');\n        return val;\n    }\n    function estimateCoords(cm, pos) {\n        let left = 0;\n        pos = b.clipPos(cm.doc, pos);\n        if (!cm.options.lineWrapping)\n            left = charWidth(cm.display) * pos.ch;\n        let lineObj = d.getLine(cm.doc, pos.line);\n        let top = c.heightAtLine(lineObj) + paddingTop(cm.display);\n        return {\n            left: left,\n            right: left,\n            top: top,\n            bottom: top + lineObj.height\n        };\n    }\n    function PosWithInfo(line, ch, sticky, outside, xRel) {\n        let pos = b.Pos(line, ch, sticky);\n        pos.xRel = xRel;\n        if (outside)\n            pos.outside = true;\n        return pos;\n    }\n    function coordsChar(cm, x, y) {\n        let doc = cm.doc;\n        y += cm.display.viewOffset;\n        if (y < 0)\n            return PosWithInfo(doc.first, 0, null, true, -1);\n        let lineN = d.lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n        if (lineN > last)\n            return PosWithInfo(doc.first + doc.size - 1, d.getLine(doc, last).text.length, null, true, 1);\n        if (x < 0)\n            x = 0;\n        let lineObj = d.getLine(doc, lineN);\n        for (;;) {\n            let found = coordsCharInner(cm, lineObj, lineN, x, y);\n            let collapsed = c.collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));\n            if (!collapsed)\n                return found;\n            let rangeEnd = collapsed.find(1);\n            if (rangeEnd.line == lineN)\n                return rangeEnd;\n            lineObj = d.getLine(doc, lineN = rangeEnd.line);\n        }\n    }\n    function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n        y -= widgetTopHeight(lineObj);\n        let end = lineObj.text.length;\n        let begin = j.findFirst(ch => measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y, end, 0);\n        end = j.findFirst(ch => measureCharPrepared(cm, preparedMeasure, ch).top > y, begin, end);\n        return {\n            begin,\n            end\n        };\n    }\n    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n        if (!preparedMeasure)\n            preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        let targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), 'line').top;\n        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n    }\n    function boxIsAfter(box, x, y, left) {\n        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n    }\n    function coordsCharInner(cm, lineObj, lineNo, x, y) {\n        y -= c.heightAtLine(lineObj);\n        let preparedMeasure = prepareMeasureForLine(cm, lineObj);\n        let widgetHeight = widgetTopHeight(lineObj);\n        let begin = 0, end = lineObj.text.length, ltr = true;\n        let order = e.getOrder(lineObj, cm.doc.direction);\n        if (order) {\n            let part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);\n            ltr = part.level != 1;\n            begin = ltr ? part.from : part.to - 1;\n            end = ltr ? part.to : part.from - 1;\n        }\n        let chAround = null, boxAround = null;\n        let ch = j.findFirst(ch => {\n            let box = measureCharPrepared(cm, preparedMeasure, ch);\n            box.top += l.widgetHeight;\n            box.bottom += l.widgetHeight;\n            if (!boxIsAfter(box, x, y, false))\n                return false;\n            if (box.top <= y && box.left <= x) {\n                chAround = ch;\n                boxAround = box;\n            }\n            return true;\n        }, begin, end);\n        let baseX, sticky, outside = false;\n        if (boxAround) {\n            let atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n            ch = chAround + (atStart ? 0 : 1);\n            sticky = atStart ? 'after' : 'before';\n            baseX = atLeft ? boxAround.left : boxAround.right;\n        } else {\n            if (!ltr && (ch == end || ch == begin))\n                ch++;\n            sticky = ch == 0 ? 'after' : ch == lineObj.text.length ? 'before' : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + l.widgetHeight <= y == ltr ? 'after' : 'before';\n            let coords = cursorCoords(cm, b.Pos(lineNo, ch, sticky), 'line', lineObj, preparedMeasure);\n            baseX = coords.left;\n            outside = y < coords.top || y >= coords.bottom;\n        }\n        ch = j.skipExtendingChars(lineObj.text, ch, 1);\n        return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);\n    }\n    function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n        let index = j.findFirst(i => {\n            let part = order[i], ltr = part.level != 1;\n            return boxIsAfter(cursorCoords(cm, b.Pos(lineNo, ltr ? part.to : part.from, ltr ? 'before' : 'after'), 'line', lineObj, preparedMeasure), x, y, true);\n        }, 0, order.length - 1);\n        let part = order[index];\n        if (index > 0) {\n            let ltr = part.level != 1;\n            let start = cursorCoords(cm, b.Pos(lineNo, ltr ? part.from : part.to, ltr ? 'after' : 'before'), 'line', lineObj, preparedMeasure);\n            if (boxIsAfter(start, x, y, true) && start.top > y)\n                part = order[index - 1];\n        }\n        return part;\n    }\n    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n        let {begin, end} = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n        if (/\\s/.test(lineObj.text.charAt(end - 1)))\n            end--;\n        let part = null, closestDist = null;\n        for (let i = 0; i < order.length; i++) {\n            let p = order[i];\n            if (p.from >= end || p.to <= begin)\n                continue;\n            let ltr = p.level != 1;\n            let endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n            let dist = endX < x ? x - endX + 1000000000 : endX - x;\n            if (!part || closestDist > dist) {\n                part = p;\n                closestDist = dist;\n            }\n        }\n        if (!part)\n            part = order[order.length - 1];\n        if (part.from < begin)\n            part = {\n                from: begin,\n                to: part.to,\n                level: part.level\n            };\n        if (part.to > end)\n            part = {\n                from: part.from,\n                to: end,\n                level: part.level\n            };\n        return part;\n    }\n    let measureText;\n    function textHeight(display) {\n        if (display.cachedTextHeight != null)\n            return display.cachedTextHeight;\n        if (measureText == null) {\n            measureText = g.elt('pre');\n            for (let i = 0; i < 49; ++i) {\n                measureText.appendChild(document.createTextNode('x'));\n                measureText.appendChild(g.elt('br'));\n            }\n            measureText.appendChild(document.createTextNode('x'));\n        }\n        g.removeChildrenAndAdd(display.measure, measureText);\n        let height = measureText.offsetHeight / 50;\n        if (height > 3)\n            display.cachedTextHeight = height;\n        g.removeChildren(display.measure);\n        return height || 1;\n    }\n    function charWidth(display) {\n        if (display.cachedCharWidth != null)\n            return display.cachedCharWidth;\n        let anchor = g.elt('span', 'xxxxxxxxxx');\n        let pre = g.elt('pre', [anchor]);\n        g.removeChildrenAndAdd(display.measure, pre);\n        let rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n        if (width > 2)\n            display.cachedCharWidth = width;\n        return width || 10;\n    }\n    function getDimensions(cm) {\n        let d = cm.display, left = {}, width = {};\n        let gutterLeft = d.gutters.clientLeft;\n        for (let n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n            left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n            width[cm.options.gutters[i]] = n.clientWidth;\n        }\n        return {\n            fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth\n        };\n    }\n    function compensateForHScroll(display) {\n        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n    }\n    function estimateHeight(cm) {\n        let th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n        let perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n        return line => {\n            if (c.lineIsHidden(cm.doc, line))\n                return 0;\n            let widgetsHeight = 0;\n            if (line.widgets)\n                for (let i = 0; i < line.widgets.length; i++) {\n                    if (line.widgets[i].height)\n                        widgetsHeight += line.widgets[i].height;\n                }\n            if (wrapping)\n                return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n            else\n                return widgetsHeight + th;\n        };\n    }\n    function estimateLineHeights(cm) {\n        let doc = cm.doc, est = estimateHeight(cm);\n        doc.iter(line => {\n            let estHeight = est(line);\n            if (estHeight != line.height)\n                d.updateLineHeight(line, estHeight);\n        });\n    }\n    function posFromMouse(cm, e, liberal, forRect) {\n        let display = cm.display;\n        if (!liberal && h.e_target(e).getAttribute('cm-not-content') == 'true')\n            return null;\n        let x, y, space = display.lineSpace.getBoundingClientRect();\n        try {\n            x = e.clientX - space.left;\n            y = e.clientY - space.top;\n        } catch (e) {\n            return null;\n        }\n        let coords = coordsChar(cm, x, y), line;\n        if (forRect && coords.xRel == 1 && (line = d.getLine(cm.doc, coords.line).text).length == coords.ch) {\n            let colDiff = j.countColumn(line, line.length, cm.options.tabSize) - line.length;\n            coords = b.Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n        }\n        return coords;\n    }\n    function findViewIndex(cm, n) {\n        if (n >= cm.display.viewTo)\n            return null;\n        n -= cm.display.viewFrom;\n        if (n < 0)\n            return null;\n        let view = cm.display.view;\n        for (let i = 0; i < view.length; i++) {\n            n -= view[i].size;\n            if (n < 0)\n                return i;\n        }\n    }\n    return {\n        paddingTop: paddingTop,\n        paddingVert: paddingVert,\n        paddingH: paddingH,\n        scrollGap: scrollGap,\n        displayWidth: displayWidth,\n        displayHeight: displayHeight,\n        mapFromLineView: mapFromLineView,\n        measureChar: measureChar,\n        findViewForLine: findViewForLine,\n        prepareMeasureForLine: prepareMeasureForLine,\n        measureCharPrepared: measureCharPrepared,\n        nodeAndOffsetInLineMap: nodeAndOffsetInLineMap,\n        clearLineMeasurementCacheFor: clearLineMeasurementCacheFor,\n        clearLineMeasurementCache: clearLineMeasurementCache,\n        clearCaches: clearCaches,\n        intoCoordSystem: intoCoordSystem,\n        fromCoordSystem: fromCoordSystem,\n        charCoords: charCoords,\n        cursorCoords: cursorCoords,\n        estimateCoords: estimateCoords,\n        coordsChar: coordsChar,\n        wrappedLineExtentChar: wrappedLineExtentChar,\n        textHeight: textHeight,\n        charWidth: charWidth,\n        getDimensions: getDimensions,\n        compensateForHScroll: compensateForHScroll,\n        estimateHeight: estimateHeight,\n        estimateLineHeights: estimateLineHeights,\n        posFromMouse: posFromMouse,\n        findViewIndex: findViewIndex\n    };\n});"]}