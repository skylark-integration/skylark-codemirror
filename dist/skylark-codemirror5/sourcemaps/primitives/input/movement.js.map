{"version":3,"sources":["primitives/input/movement.js"],"names":["define","a","b","c","d","moveCharLogically","line","ch","dir","target","skipExtendingChars","text","length","moveLogically","start","Pos","endOfLine","visually","cm","lineObj","lineNo","order","getOrder","doc","direction","part","lst","sticky","level","prep","prepareMeasureForLine","targetTop","measureCharPrepared","top","findFirst","from","to","moveVisually","bidi","partPos","getBidiPartAt","mv","pos","getWrappedLineExtent","options","lineWrapping","wrappedLineExtentChar","begin","end","wrappedLineExtent","moveInStorageOrder","searchInVisualLine","getRes","res","nextCh"],"mappings":"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","file":"../../../primitives/input/movement.js","sourcesContent":["define([\n    '../line/pos',\n    '../measurement/position_measurement',\n    '../util/bidi',\n    '../util/misc'\n], function (a, b, c, d) {\n    'use strict';\n    function moveCharLogically(line, ch, dir) {\n        let target = d.skipExtendingChars(line.text, ch + dir, dir);\n        return target < 0 || target > line.text.length ? null : target;\n    }\n    function moveLogically(line, start, dir) {\n        let ch = moveCharLogically(line, start.ch, dir);\n        return ch == null ? null : new a.Pos(start.line, ch, dir < 0 ? 'after' : 'before');\n    }\n    function endOfLine(visually, cm, lineObj, lineNo, dir) {\n        if (visually) {\n            let order = c.getOrder(lineObj, cm.doc.direction);\n            if (order) {\n                let part = dir < 0 ? d.lst(order) : order[0];\n                let moveInStorageOrder = dir < 0 == (part.level == 1);\n                let sticky = moveInStorageOrder ? 'after' : 'before';\n                let ch;\n                if (part.level > 0 || cm.doc.direction == 'rtl') {\n                    let prep = b.prepareMeasureForLine(cm, lineObj);\n                    ch = dir < 0 ? lineObj.text.length - 1 : 0;\n                    let targetTop = b.measureCharPrepared(cm, prep, ch).top;\n                    ch = d.findFirst(ch => b.measureCharPrepared(cm, prep, ch).top == targetTop, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n                    if (sticky == 'before')\n                        ch = moveCharLogically(lineObj, ch, 1);\n                } else\n                    ch = dir < 0 ? part.to : part.from;\n                return new a.Pos(lineNo, ch, sticky);\n            }\n        }\n        return new a.Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? 'before' : 'after');\n    }\n    function moveVisually(cm, line, start, dir) {\n        let bidi = c.getOrder(line, cm.doc.direction);\n        if (!bidi)\n            return moveLogically(line, start, dir);\n        if (start.ch >= line.text.length) {\n            start.ch = line.text.length;\n            start.sticky = 'before';\n        } else if (start.ch <= 0) {\n            start.ch = 0;\n            start.sticky = 'after';\n        }\n        let partPos = c.getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n        if (cm.doc.direction == 'ltr' && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n            return moveLogically(line, start, dir);\n        }\n        let mv = (pos, dir) => moveCharLogically(line, pos instanceof a.Pos ? pos.ch : pos, dir);\n        let prep;\n        let getWrappedLineExtent = ch => {\n            if (!cm.options.lineWrapping)\n                return {\n                    begin: 0,\n                    end: line.text.length\n                };\n            prep = prep || b.prepareMeasureForLine(cm, line);\n            return b.wrappedLineExtentChar(cm, line, prep, ch);\n        };\n        let wrappedLineExtent = getWrappedLineExtent(start.sticky == 'before' ? mv(start, -1) : start.ch);\n        if (cm.doc.direction == 'rtl' || part.level == 1) {\n            let moveInStorageOrder = part.level == 1 == dir < 0;\n            let ch = mv(start, moveInStorageOrder ? 1 : -1);\n            if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n                let sticky = moveInStorageOrder ? 'before' : 'after';\n                return new a.Pos(start.line, ch, sticky);\n            }\n        }\n        let searchInVisualLine = (partPos, dir, wrappedLineExtent) => {\n            let getRes = (ch, moveInStorageOrder) => moveInStorageOrder ? new a.Pos(start.line, mv(ch, 1), 'before') : new a.Pos(start.line, ch, 'after');\n            for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n                let part = bidi[partPos];\n                let moveInStorageOrder = dir > 0 == (part.level != 1);\n                let ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n                if (part.from <= ch && ch < part.to)\n                    return getRes(ch, moveInStorageOrder);\n                ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n                if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end)\n                    return getRes(ch, moveInStorageOrder);\n            }\n        };\n        let res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n        if (res)\n            return res;\n        let nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n            res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n            if (res)\n                return res;\n        }\n        return null;\n    }\n    return {\n        moveLogically: moveLogically,\n        endOfLine: endOfLine,\n        moveVisually: moveVisually\n    };\n});"]}