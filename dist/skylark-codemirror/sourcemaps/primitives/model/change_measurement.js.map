{"version":3,"sources":["primitives/model/change_measurement.js"],"names":["define","a","b","c","changeEnd","change","text","Pos","from","line","length","lst","ch","to","adjustForChange","pos","cmp","offsetPos","old","nw","computeSelAfterChange","doc","out","i","sel","ranges","range","push","Range","anchor","head","normalizeSelection","cm","primIndex","computeReplacedSel","changes","hint","oldPrev","first","newPrev","inv","Selection"],"mappings":";;;;;;;AAAAA,QACI,cACA,eACA,eACD,SAAUC,EAAGC,EAAGC,GACf,aACA,SAASC,EAAUC,GACf,OAAKA,EAAOC,KAELL,EAAEM,IAAIF,EAAOG,KAAKC,KAAOJ,EAAOC,KAAKI,OAAS,EAAGR,EAAES,IAAIN,EAAOC,MAAMI,QAAgC,GAAtBL,EAAOC,KAAKI,OAAcL,EAAOG,KAAKI,GAAK,IADrHP,EAAOQ,GAGtB,SAASC,EAAgBC,EAAKV,GAC1B,GAAIJ,EAAEe,IAAID,EAAKV,EAAOG,MAAQ,EAC1B,OAAOO,EACX,GAAId,EAAEe,IAAID,EAAKV,EAAOQ,KAAO,EACzB,OAAOT,EAAUC,GACrB,IAAII,EAAOM,EAAIN,KAAOJ,EAAOC,KAAKI,QAAUL,EAAOQ,GAAGJ,KAAOJ,EAAOG,KAAKC,MAAQ,EAAGG,EAAKG,EAAIH,GAG7F,OAFIG,EAAIN,MAAQJ,EAAOQ,GAAGJ,OACtBG,GAAMR,EAAUC,GAAQO,GAAKP,EAAOQ,GAAGD,IACpCX,EAAEM,IAAIE,EAAMG,GAUvB,SAASK,EAAUF,EAAKG,EAAKC,GACzB,OAAIJ,EAAIN,MAAQS,EAAIT,KACTR,EAAEM,IAAIY,EAAGV,KAAMM,EAAIH,GAAKM,EAAIN,GAAKO,EAAGP,IAEpCX,EAAEM,IAAIY,EAAGV,MAAQM,EAAIN,KAAOS,EAAIT,MAAOM,EAAIH,IAoB1D,OACIR,UAAWA,EACXgB,sBAlCJ,SAA+BC,EAAKhB,GAChC,IAAIiB,KACJ,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAIG,IAAIC,OAAOf,OAAQa,IAAK,CAC5C,IAAIG,EAAQL,EAAIG,IAAIC,OAAOF,GAC3BD,EAAIK,KAAK,IAAIxB,EAAEyB,MAAMd,EAAgBY,EAAMG,OAAQxB,GAASS,EAAgBY,EAAMI,KAAMzB,KAE5F,OAAOF,EAAE4B,mBAAmBV,EAAIW,GAAIV,EAAKD,EAAIG,IAAIS,YA6BjDC,mBArBJ,SAA4Bb,EAAKc,EAASC,GACtC,IAAId,KACAe,EAAUpC,EAAEM,IAAIc,EAAIiB,MAAO,GAAIC,EAAUF,EAC7C,IAAK,IAAId,EAAI,EAAGA,EAAIY,EAAQzB,OAAQa,IAAK,CACrC,IAAIlB,EAAS8B,EAAQZ,GACjBf,EAAOS,EAAUZ,EAAOG,KAAM6B,EAASE,GACvC1B,EAAKI,EAAUb,EAAUC,GAASgC,EAASE,GAG/C,GAFAF,EAAUhC,EAAOQ,GACjB0B,EAAU1B,EACE,UAARuB,EAAkB,CAClB,IAAIV,EAAQL,EAAIG,IAAIC,OAAOF,GAAIiB,EAAMvC,EAAEe,IAAIU,EAAMI,KAAMJ,EAAMG,QAAU,EACvEP,EAAIC,GAAK,IAAIpB,EAAEyB,MAAMY,EAAM3B,EAAKL,EAAMgC,EAAMhC,EAAOK,QAEnDS,EAAIC,GAAK,IAAIpB,EAAEyB,MAAMpB,EAAMA,GAGnC,OAAO,IAAIL,EAAEsC,UAAUnB,EAAKD,EAAIG,IAAIS","file":"../../../primitives/model/change_measurement.js","sourcesContent":["define([\n    '../line/pos',\n    '../util/misc',\n    './selection'\n], function (a, b, c) {\n    'use strict';\n    function changeEnd(change) {\n        if (!change.text)\n            return change.to;\n        return a.Pos(change.from.line + change.text.length - 1, b.lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n    }\n    function adjustForChange(pos, change) {\n        if (a.cmp(pos, change.from) < 0)\n            return pos;\n        if (a.cmp(pos, change.to) <= 0)\n            return changeEnd(change);\n        let line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n        if (pos.line == change.to.line)\n            ch += changeEnd(change).ch - change.to.ch;\n        return a.Pos(line, ch);\n    }\n    function computeSelAfterChange(doc, change) {\n        let out = [];\n        for (let i = 0; i < doc.sel.ranges.length; i++) {\n            let range = doc.sel.ranges[i];\n            out.push(new c.Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));\n        }\n        return c.normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    }\n    function offsetPos(pos, old, nw) {\n        if (pos.line == old.line)\n            return a.Pos(nw.line, pos.ch - old.ch + nw.ch);\n        else\n            return a.Pos(nw.line + (pos.line - old.line), pos.ch);\n    }\n    function computeReplacedSel(doc, changes, hint) {\n        let out = [];\n        let oldPrev = a.Pos(doc.first, 0), newPrev = oldPrev;\n        for (let i = 0; i < changes.length; i++) {\n            let change = changes[i];\n            let from = offsetPos(change.from, oldPrev, newPrev);\n            let to = offsetPos(changeEnd(change), oldPrev, newPrev);\n            oldPrev = change.to;\n            newPrev = to;\n            if (hint == 'around') {\n                let range = doc.sel.ranges[i], inv = a.cmp(range.head, range.anchor) < 0;\n                out[i] = new c.Range(inv ? to : from, inv ? from : to);\n            } else {\n                out[i] = new c.Range(from, from);\n            }\n        }\n        return new c.Selection(out, doc.sel.primIndex);\n    }\n    return {\n        changeEnd: changeEnd,\n        computeSelAfterChange: computeSelAfterChange,\n        computeReplacedSel: computeReplacedSel\n    };\n});"]}