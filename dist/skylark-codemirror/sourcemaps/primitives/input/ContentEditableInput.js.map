{"version":3,"sources":["primitives/input/ContentEditableInput.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","ContentEditableInput","[object Object]","cm","this","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","Delayed","composing","gracePeriod","readDOMTimeout","display","input","div","lineDiv","onCopyCut","signalDOMEvent","somethingSelected","setLastCopied","lineWise","text","getSelections","type","replaceSelection","options","lineWiseCopyCut","ranges","copyableRanges","undefined","setSelections","sel_dontScroll","clipboardData","clearData","content","lastCopied","join","setData","getData","preventDefault","kludge","hiddenTextarea","te","firstChild","lineSpace","insertBefore","value","hadFocus","document","activeElement","selectInput","setTimeout","removeChild","focus","showPrimarySelection","disableBrowserMagic","spellcheck","autocorrect","autocapitalize","on","handlePaste","ie_version","operation","updateFromDOM","data","done","readFromDOMSoon","forceCompositionEnd","result","prepareSelection","state","focused","info","takeFocus","view","length","showMultipleSelections","wrapper","ownerDocument","getSelection","sel","prim","doc","primary","from","to","viewTo","viewFrom","line","removeAllRanges","curAnchor","domToPos","anchorNode","anchorOffset","curFocus","focusNode","focusOffset","bad","cmp","minPos","maxPos","start","posToDOM","node","measure","map","offset","end","maps","rng","old","rangeCount","getRangeAt","range","gecko","collapse","collapsed","addRange","startGracePeriod","rememberSelection","clearTimeout","selectionChanged","curOp","removeChildrenAndAdd","cursorDiv","cursors","selectionDiv","selection","commonAncestorContainer","contains","readOnly","selectionInEditor","showSelection","blur","pollSelection","runInOp","set","pollInterval","poll","android","chrome","gutters","scan","parentNode","test","className","isInGutter","triggerOnKeyDown","keyCode","Math","abs","anchor","head","setSelection","simpleSelection","fromIndex","fromLine","fromNode","ch","firstLine","Pos","getLine","lastLine","findViewIndex","lineNo","nextSibling","toLine","toNode","toIndex","lastChild","previousSibling","newText","splitLines","closing","lineSep","lineSeparator","extraLinebreak","close","addText","str","walk","nodeType","cmText","getAttribute","markerID","found","findMarks","id","marker","find","getBetween","isBlock","nodeName","textContent","childNodes","nodeValue","replace","domTextBetween","oldText","lst","pop","shift","cutFront","cutEnd","newTop","oldTop","maxCutFront","min","charCodeAt","newBot","oldBot","maxCutEnd","slice","chFrom","chTo","replaceRange","isReadOnly","pollContent","regChange","contentEditable","charCode","applyTextInput","String","fromCharCode","val","pos","findViewForLine","hidden","mapFromLineView","order","getOrder","direction","side","getBidiPartAt","nodeAndOffsetInLineMap","badPos","lineNode","clipPos","lineView","locateNodeInLineView","rest","textNode","topNode","curNode","after","dist","before","prototype","needsContentAttribute"],"mappings":"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","file":"../../../primitives/input/ContentEditableInput.js","sourcesContent":["define([\n    '../display/operations',\n    '../display/selection',\n    '../display/view_tracking',\n    './input',\n    '../line/pos',\n    '../line/utils_line',\n    '../measurement/position_measurement',\n    '../model/changes',\n    '../model/selection',\n    '../model/selection_updates',\n    '../util/bidi',\n    '../util/browser',\n    '../util/dom',\n    '../util/event',\n    '../util/misc'\n], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) {\n    'use strict';\n    class ContentEditableInput {\n        constructor(cm) {\n            this.cm = cm;\n            this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n            this.polling = new o.Delayed();\n            this.composing = null;\n            this.gracePeriod = false;\n            this.readDOMTimeout = null;\n        }\n        init(display) {\n            let input = this, cm = input.cm;\n            let div = input.div = display.lineDiv;\n            d.disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n            n.on(div, 'paste', e => {\n                if (n.signalDOMEvent(cm, e) || d.handlePaste(e, cm))\n                    return;\n                if (l.ie_version <= 11)\n                    setTimeout(a.operation(cm, () => this.updateFromDOM()), 20);\n            });\n            n.on(div, 'compositionstart', e => {\n                this.composing = {\n                    data: e.data,\n                    done: false\n                };\n            });\n            n.on(div, 'compositionupdate', e => {\n                if (!this.composing)\n                    this.composing = {\n                        data: e.data,\n                        done: false\n                    };\n            });\n            n.on(div, 'compositionend', e => {\n                if (this.composing) {\n                    if (e.data != this.composing.data)\n                        this.readFromDOMSoon();\n                    this.composing.done = true;\n                }\n            });\n            n.on(div, 'touchstart', () => input.forceCompositionEnd());\n            n.on(div, 'input', () => {\n                if (!this.composing)\n                    this.readFromDOMSoon();\n            });\n            function onCopyCut(e) {\n                if (n.signalDOMEvent(cm, e))\n                    return;\n                if (cm.somethingSelected()) {\n                    d.setLastCopied({\n                        lineWise: false,\n                        text: cm.getSelections()\n                    });\n                    if (e.type == 'cut')\n                        cm.replaceSelection('', null, 'cut');\n                } else if (!cm.options.lineWiseCopyCut) {\n                    return;\n                } else {\n                    let ranges = d.copyableRanges(cm);\n                    d.setLastCopied({\n                        lineWise: true,\n                        text: ranges.text\n                    });\n                    if (e.type == 'cut') {\n                        cm.undefined(() => {\n                            cm.setSelections(ranges.ranges, 0, o.sel_dontScroll);\n                            cm.replaceSelection('', null, 'cut');\n                        });\n                    }\n                }\n                if (e.clipboardData) {\n                    e.clipboardData.clearData();\n                    let content = d.lastCopied.text.join('\\n');\n                    e.clipboardData.setData('Text', content);\n                    if (e.clipboardData.getData('Text') == content) {\n                        e.preventDefault();\n                        return;\n                    }\n                }\n                let kludge = d.hiddenTextarea(), te = kludge.firstChild;\n                cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n                te.value = d.lastCopied.text.join('\\n');\n                let hadFocus = document.activeElement;\n                m.selectInput(te);\n                setTimeout(() => {\n                    cm.display.lineSpace.removeChild(kludge);\n                    hadFocus.focus();\n                    if (hadFocus == div)\n                        input.showPrimarySelection();\n                }, 50);\n            }\n            n.on(div, 'copy', onCopyCut);\n            n.on(div, 'cut', onCopyCut);\n        }\n        prepareSelection() {\n            let result = b.prepareSelection(this.cm, false);\n            result.focus = this.cm.state.focused;\n            return result;\n        }\n        showSelection(info, takeFocus) {\n            if (!info || !this.cm.display.view.length)\n                return;\n            if (info.focus || takeFocus)\n                this.showPrimarySelection();\n            this.showMultipleSelections(info);\n        }\n        getSelection() {\n            return this.cm.display.wrapper.ownerDocument.getSelection();\n        }\n        showPrimarySelection() {\n            let sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n            let from = prim.from(), to = prim.to();\n            if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n                sel.removeAllRanges();\n                return;\n            }\n            let curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n            let curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n            if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && e.cmp(e.minPos(curAnchor, curFocus), from) == 0 && e.cmp(e.maxPos(curAnchor, curFocus), to) == 0)\n                return;\n            let view = cm.display.view;\n            let start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n                node: view[0].measure.map[2],\n                offset: 0\n            };\n            let end = to.line < cm.display.viewTo && posToDOM(cm, to);\n            if (!end) {\n                let measure = view[view.length - 1].measure;\n                let map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n                end = {\n                    node: map[map.length - 1],\n                    offset: map[map.length - 2] - map[map.length - 3]\n                };\n            }\n            if (!start || !end) {\n                sel.removeAllRanges();\n                return;\n            }\n            let old = sel.rangeCount && sel.getRangeAt(0), rng;\n            try {\n                rng = m.range(start.node, start.offset, end.offset, end.node);\n            } catch (e) {\n            }\n            if (rng) {\n                if (!l.gecko && cm.state.focused) {\n                    sel.collapse(start.node, start.offset);\n                    if (!rng.collapsed) {\n                        sel.removeAllRanges();\n                        sel.addRange(rng);\n                    }\n                } else {\n                    sel.removeAllRanges();\n                    sel.addRange(rng);\n                }\n                if (old && sel.anchorNode == null)\n                    sel.addRange(old);\n                else if (l.gecko)\n                    this.startGracePeriod();\n            }\n            this.rememberSelection();\n        }\n        startGracePeriod() {\n            clearTimeout(this.gracePeriod);\n            this.gracePeriod = setTimeout(() => {\n                this.gracePeriod = false;\n                if (this.selectionChanged())\n                    this.cm.undefined(() => this.cm.curOp.selectionChanged = true);\n            }, 20);\n        }\n        showMultipleSelections(info) {\n            m.removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n            m.removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n        }\n        rememberSelection() {\n            let sel = this.getSelection();\n            this.lastAnchorNode = sel.anchorNode;\n            this.lastAnchorOffset = sel.anchorOffset;\n            this.lastFocusNode = sel.focusNode;\n            this.lastFocusOffset = sel.focusOffset;\n        }\n        selectionInEditor() {\n            let sel = this.getSelection();\n            if (!sel.rangeCount)\n                return false;\n            let node = sel.getRangeAt(0).commonAncestorContainer;\n            return m.contains(this.div, node);\n        }\n        focus() {\n            if (this.cm.options.readOnly != 'nocursor') {\n                if (!this.selectionInEditor())\n                    this.showSelection(this.undefined(), true);\n                this.div.focus();\n            }\n        }\n        blur() {\n            this.div.blur();\n        }\n        getField() {\n            return this.div;\n        }\n        supportsTouch() {\n            return true;\n        }\n        receivedFocus() {\n            let input = this;\n            if (this.selectionInEditor())\n                this.pollSelection();\n            else\n                a.runInOp(this.cm, () => input.cm.curOp.selectionChanged = true);\n            function poll() {\n                if (input.cm.state.focused) {\n                    input.pollSelection();\n                    input.polling.set(input.cm.options.pollInterval, poll);\n                }\n            }\n            this.polling.set(this.cm.options.pollInterval, poll);\n        }\n        selectionChanged() {\n            let sel = this.getSelection();\n            return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n        }\n        pollSelection() {\n            if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())\n                return;\n            let sel = this.getSelection(), cm = this.cm;\n            if (l.android && l.chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n                this.cm.triggerOnKeyDown({\n                    type: 'keydown',\n                    keyCode: 8,\n                    preventDefault: Math.abs\n                });\n                this.blur();\n                this.focus();\n                return;\n            }\n            if (this.composing)\n                return;\n            this.rememberSelection();\n            let anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n            let head = domToPos(cm, sel.focusNode, sel.focusOffset);\n            if (anchor && head)\n                a.runInOp(cm, () => {\n                    j.setSelection(cm.doc, i.simpleSelection(anchor, head), o.sel_dontScroll);\n                    if (anchor.bad || head.bad)\n                        cm.curOp.selectionChanged = true;\n                });\n        }\n        pollContent() {\n            if (this.readDOMTimeout != null) {\n                clearTimeout(this.readDOMTimeout);\n                this.readDOMTimeout = null;\n            }\n            let cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n            let from = sel.from(), to = sel.to();\n            if (from.ch == 0 && from.line > cm.firstLine())\n                from = e.Pos(from.line - 1, f.getLine(cm.doc, from.line - 1).length);\n            if (to.ch == f.getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n                to = e.Pos(to.line + 1, 0);\n            if (from.line < display.viewFrom || to.line > display.viewTo - 1)\n                return false;\n            let fromIndex, fromLine, fromNode;\n            if (from.line == display.viewFrom || (fromIndex = g.findViewIndex(cm, from.line)) == 0) {\n                fromLine = f.lineNo(display.view[0].line);\n                fromNode = display.view[0].node;\n            } else {\n                fromLine = f.lineNo(display.view[fromIndex].line);\n                fromNode = display.view[fromIndex - 1].node.nextSibling;\n            }\n            let toIndex = g.findViewIndex(cm, to.line);\n            let toLine, toNode;\n            if (toIndex == display.view.length - 1) {\n                toLine = display.viewTo - 1;\n                toNode = display.lineDiv.lastChild;\n            } else {\n                toLine = f.lineNo(display.view[toIndex + 1].line) - 1;\n                toNode = display.view[toIndex + 1].node.previousSibling;\n            }\n            if (!fromNode)\n                return false;\n            let newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n            let oldText = f.getBetween(cm.doc, e.Pos(fromLine, 0), e.Pos(toLine, f.getLine(cm.doc, toLine).text.length));\n            while (newText.length > 1 && oldText.length > 1) {\n                if (o.lst(newText) == o.lst(oldText)) {\n                    newText.pop();\n                    oldText.pop();\n                    toLine--;\n                } else if (newText[0] == oldText[0]) {\n                    newText.shift();\n                    oldText.shift();\n                    fromLine++;\n                } else\n                    break;\n            }\n            let cutFront = 0, cutEnd = 0;\n            let newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n            while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n                ++cutFront;\n            let newBot = o.lst(newText), oldBot = o.lst(oldText);\n            let maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n            while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n                ++cutEnd;\n            if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n                while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n                    cutFront--;\n                    cutEnd++;\n                }\n            }\n            newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, '');\n            newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, '');\n            let chFrom = e.Pos(fromLine, cutFront);\n            let chTo = e.Pos(toLine, oldText.length ? o.lst(oldText).length - cutEnd : 0);\n            if (newText.length > 1 || newText[0] || e.cmp(chFrom, chTo)) {\n                h.replaceRange(cm.doc, newText, chFrom, chTo, '+input');\n                return true;\n            }\n        }\n        ensurePolled() {\n            this.forceCompositionEnd();\n        }\n        reset() {\n            this.forceCompositionEnd();\n        }\n        forceCompositionEnd() {\n            if (!this.composing)\n                return;\n            clearTimeout(this.readDOMTimeout);\n            this.composing = null;\n            this.updateFromDOM();\n            this.div.blur();\n            this.div.focus();\n        }\n        readFromDOMSoon() {\n            if (this.readDOMTimeout != null)\n                return;\n            this.readDOMTimeout = setTimeout(() => {\n                this.readDOMTimeout = null;\n                if (this.composing) {\n                    if (this.composing.done)\n                        this.composing = null;\n                    else\n                        return;\n                }\n                this.updateFromDOM();\n            }, 80);\n        }\n        updateFromDOM() {\n            if (this.cm.isReadOnly() || !this.pollContent())\n                a.runInOp(this.cm, () => c.regChange(this.cm));\n        }\n        setUneditable(node) {\n            node.contentEditable = 'false';\n        }\n        onKeyPress(e) {\n            if (e.charCode == 0 || this.composing)\n                return;\n            e.preventDefault();\n            if (!this.cm.isReadOnly())\n                a.operation(this.cm, d.applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n        }\n        readOnlyChanged(val) {\n            this.div.contentEditable = String(val != 'nocursor');\n        }\n        onContextMenu() {\n        }\n        resetPosition() {\n        }\n    };\n    ContentEditableInput.prototype.needsContentAttribute = true;\n    function posToDOM(cm, pos) {\n        let view = g.findViewForLine(cm, pos.line);\n        if (!view || view.hidden)\n            return null;\n        let line = f.getLine(cm.doc, pos.line);\n        let info = g.mapFromLineView(view, line, pos.line);\n        let order = k.getOrder(line, cm.doc.direction), side = 'left';\n        if (order) {\n            let partPos = k.getBidiPartAt(order, pos.ch);\n            side = partPos % 2 ? 'right' : 'left';\n        }\n        let result = g.nodeAndOffsetInLineMap(info.map, pos.ch, side);\n        result.offset = result.collapse == 'right' ? result.end : result.start;\n        return result;\n    }\n    function isInGutter(node) {\n        for (let scan = node; scan; scan = scan.parentNode)\n            if (/CodeMirror-gutter-wrapper/.test(scan.className))\n                return true;\n        return false;\n    }\n    function badPos(pos, bad) {\n        if (bad)\n            pos.bad = true;\n        return pos;\n    }\n    function domTextBetween(cm, from, to, fromLine, toLine) {\n        let text = '', closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n        function recognizeMarker(id) {\n            return marker => marker.id == id;\n        }\n        function close() {\n            if (closing) {\n                text += lineSep;\n                if (extraLinebreak)\n                    text += lineSep;\n                closing = extraLinebreak = false;\n            }\n        }\n        function addText(str) {\n            if (str) {\n                close();\n                text += str;\n            }\n        }\n        function walk(node) {\n            if (node.nodeType == 1) {\n                let cmText = node.getAttribute('cm-text');\n                if (cmText) {\n                    addText(cmText);\n                    return;\n                }\n                let markerID = node.getAttribute('cm-marker'), range;\n                if (markerID) {\n                    let found = cm.findMarks(e.Pos(fromLine, 0), e.Pos(toLine + 1, 0), recognizeMarker(+markerID));\n                    if (found.length && (range = found[0].find(0)))\n                        addText(f.getBetween(cm.doc, range.from, range.to).join(lineSep));\n                    return;\n                }\n                if (node.getAttribute('contenteditable') == 'false')\n                    return;\n                let isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n                if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0)\n                    return;\n                if (isBlock)\n                    close();\n                for (let i = 0; i < node.childNodes.length; i++)\n                    walk(node.childNodes[i]);\n                if (/^(pre|p)$/i.test(node.nodeName))\n                    extraLinebreak = true;\n                if (isBlock)\n                    closing = true;\n            } else if (node.nodeType == 3) {\n                addText(node.nodeValue.replace(/\\u200b/g, '').replace(/\\u00a0/g, ' '));\n            }\n        }\n        for (;;) {\n            walk(from);\n            if (from == to)\n                break;\n            from = from.nextSibling;\n            extraLinebreak = false;\n        }\n        return text;\n    }\n    function domToPos(cm, node, offset) {\n        let lineNode;\n        if (node == cm.display.lineDiv) {\n            lineNode = cm.display.lineDiv.childNodes[offset];\n            if (!lineNode)\n                return badPos(cm.clipPos(e.Pos(cm.display.viewTo - 1)), true);\n            node = null;\n            offset = 0;\n        } else {\n            for (lineNode = node;; lineNode = lineNode.parentNode) {\n                if (!lineNode || lineNode == cm.display.lineDiv)\n                    return null;\n                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)\n                    break;\n            }\n        }\n        for (let i = 0; i < cm.display.view.length; i++) {\n            let lineView = cm.display.view[i];\n            if (lineView.node == lineNode)\n                return locateNodeInLineView(lineView, node, offset);\n        }\n    }\n    function locateNodeInLineView(lineView, node, offset) {\n        let wrapper = lineView.text.firstChild, bad = false;\n        if (!node || !m.contains(wrapper, node))\n            return badPos(e.Pos(f.lineNo(lineView.line), 0), true);\n        if (node == wrapper) {\n            bad = true;\n            node = wrapper.childNodes[offset];\n            offset = 0;\n            if (!node) {\n                let line = lineView.rest ? o.lst(lineView.rest) : lineView.line;\n                return badPos(e.Pos(f.lineNo(line), line.text.length), bad);\n            }\n        }\n        let textNode = node.nodeType == 3 ? node : null, topNode = node;\n        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n            textNode = node.firstChild;\n            if (offset)\n                offset = textNode.nodeValue.length;\n        }\n        while (topNode.parentNode != wrapper)\n            topNode = topNode.parentNode;\n        let measure = lineView.measure, maps = measure.maps;\n        function find(textNode, topNode, offset) {\n            for (let i = -1; i < (maps ? maps.length : 0); i++) {\n                let map = i < 0 ? measure.map : maps[i];\n                for (let j = 0; j < map.length; j += 3) {\n                    let curNode = map[j + 2];\n                    if (curNode == textNode || curNode == topNode) {\n                        let line = f.lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n                        let ch = map[j] + offset;\n                        if (offset < 0 || curNode != textNode)\n                            ch = map[j + (offset ? 1 : 0)];\n                        return e.Pos(line, ch);\n                    }\n                }\n            }\n        }\n        let found = find(textNode, topNode, offset);\n        if (found)\n            return badPos(found, bad);\n        for (let after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n            found = find(after, after.firstChild, 0);\n            if (found)\n                return badPos(e.Pos(found.line, found.ch - dist), bad);\n            else\n                dist += after.textContent.length;\n        }\n        for (let before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n            found = find(before, before.firstChild, -1);\n            if (found)\n                return badPos(e.Pos(found.line, found.ch + dist), bad);\n            else\n                dist += before.textContent.length;\n        }\n    }\n\n    return ContentEditableInput;\n});"]}