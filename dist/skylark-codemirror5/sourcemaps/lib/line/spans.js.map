{"version":3,"sources":["lib/line/spans.js"],"names":["define","a","b","c","d","MarkedSpan","marker","from","to","this","getMarkedSpanFor","spans","i","length","span","clearEmptySpans","clearWhenEmpty","splice","extraLeft","inclusiveLeft","extraRight","inclusiveRight","compareCollapsedMarkers","lenDiff","lines","aPos","find","bPos","fromCmp","cmp","toCmp","id","collapsedSpanAtSide","line","start","found","sps","sawCollapsedSpans","markedSpans","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","visualLine","merged","lineIsHidden","doc","widgetNode","lineIsHiddenInner","end","text","lineLength","height","len","cur","ch","removeMarkedSpan","r","push","addMarkedSpan","concat","attachLine","stretchSpansOverChange","change","full","oldFirst","isLine","getLine","oldLast","startCh","endCh","isInsert","first","old","nw","type","insertLeft","endsAfter","markedSpansBefore","last","startsBefore","markedSpansAfter","sameLine","offset","lst","newMarkers","gapMarkers","gap","removeReadOnlyRanges","markers","iter","mark","readOnly","indexOf","parts","mk","m","j","p","newParts","dfrom","dto","apply","detachMarkedSpans","detachLine","attachMarkedSpans","collapsedSpanAround","conflictingCollapsedRange","lineNo","visualLineEnd","visualLineContinued","visualLineNo","lineN","vis","visualLineEndNo","lastLine","heightAtLine","lineObj","h","chunk","parent","children","findMaxLine","cm","display","maxLine","maxLineLength","maxLineChanged"],"mappings":"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","file":"../../../lib/line/spans.js","sourcesContent":["define([\n    '../util/misc',\n    './pos',\n    './saw_special_spans',\n    './utils_line'\n], function (a, b, c, d) {\n    'use strict';\n    function MarkedSpan(marker, from, to) {\n        this.marker = marker;\n        this.from = from;\n        this.to = to;\n    }\n    function getMarkedSpanFor(spans, marker) {\n        if (spans)\n            for (let i = 0; i < spans.length; ++i) {\n                let span = spans[i];\n                if (span.marker == marker)\n                    return span;\n            }\n    }\n    function removeMarkedSpan(spans, span) {\n        let r;\n        for (let i = 0; i < spans.length; ++i)\n            if (spans[i] != span)\n                (r || (r = [])).push(spans[i]);\n        return r;\n    }\n    function addMarkedSpan(line, span) {\n        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n        span.marker.attachLine(line);\n    }\n    function markedSpansBefore(old, startCh, isInsert) {\n        let nw;\n        if (old)\n            for (let i = 0; i < old.length; ++i) {\n                let span = old[i], marker = span.marker;\n                let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n                if (startsBefore || span.from == startCh && marker.type == 'bookmark' && (!isInsert || !span.marker.insertLeft)) {\n                    let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n                }\n            }\n        return nw;\n    }\n    function markedSpansAfter(old, endCh, isInsert) {\n        let nw;\n        if (old)\n            for (let i = 0; i < old.length; ++i) {\n                let span = old[i], marker = span.marker;\n                let endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n                if (endsAfter || span.from == endCh && marker.type == 'bookmark' && (!isInsert || span.marker.insertLeft)) {\n                    let startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n                }\n            }\n        return nw;\n    }\n    function stretchSpansOverChange(doc, change) {\n        if (change.full)\n            return null;\n        let oldFirst = d.isLine(doc, change.from.line) && d.getLine(doc, change.from.line).markedSpans;\n        let oldLast = d.isLine(doc, change.to.line) && d.getLine(doc, change.to.line).markedSpans;\n        if (!oldFirst && !oldLast)\n            return null;\n        let startCh = change.from.ch, endCh = change.to.ch, isInsert = b.cmp(change.from, change.to) == 0;\n        let first = markedSpansBefore(oldFirst, startCh, isInsert);\n        let last = markedSpansAfter(oldLast, endCh, isInsert);\n        let sameLine = change.text.length == 1, offset = a.lst(change.text).length + (sameLine ? startCh : 0);\n        if (first) {\n            for (let i = 0; i < first.length; ++i) {\n                let span = first[i];\n                if (span.to == null) {\n                    let found = getMarkedSpanFor(last, span.marker);\n                    if (!found)\n                        span.to = startCh;\n                    else if (sameLine)\n                        span.to = found.to == null ? null : found.to + offset;\n                }\n            }\n        }\n        if (last) {\n            for (let i = 0; i < last.length; ++i) {\n                let span = last[i];\n                if (span.to != null)\n                    span.to += offset;\n                if (span.from == null) {\n                    let found = getMarkedSpanFor(first, span.marker);\n                    if (!found) {\n                        span.from = offset;\n                        if (sameLine)\n                            (first || (first = [])).push(span);\n                    }\n                } else {\n                    span.from += offset;\n                    if (sameLine)\n                        (first || (first = [])).push(span);\n                }\n            }\n        }\n        if (first)\n            first = clearEmptySpans(first);\n        if (last && last != first)\n            last = clearEmptySpans(last);\n        let newMarkers = [first];\n        if (!sameLine) {\n            let gap = change.text.length - 2, gapMarkers;\n            if (gap > 0 && first)\n                for (let i = 0; i < first.length; ++i)\n                    if (first[i].to == null)\n                        (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n            for (let i = 0; i < gap; ++i)\n                newMarkers.push(gapMarkers);\n            newMarkers.push(last);\n        }\n        return newMarkers;\n    }\n    function clearEmptySpans(spans) {\n        for (let i = 0; i < spans.length; ++i) {\n            let span = spans[i];\n            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n                spans.splice(i--, 1);\n        }\n        if (!spans.length)\n            return null;\n        return spans;\n    }\n    function removeReadOnlyRanges(doc, from, to) {\n        let markers = null;\n        doc.iter(from.line, to.line + 1, line => {\n            if (line.markedSpans)\n                for (let i = 0; i < line.markedSpans.length; ++i) {\n                    let mark = line.markedSpans[i].marker;\n                    if (mark.readOnly && (!markers || a.indexOf(markers, mark) == -1))\n                        (markers || (markers = [])).push(mark);\n                }\n        });\n        if (!markers)\n            return null;\n        let parts = [{\n                from: from,\n                to: to\n            }];\n        for (let i = 0; i < markers.length; ++i) {\n            let mk = markers[i], m = mk.find(0);\n            for (let j = 0; j < parts.length; ++j) {\n                let p = parts[j];\n                if (b.cmp(p.to, m.from) < 0 || b.cmp(p.from, m.to) > 0)\n                    continue;\n                let newParts = [\n                        j,\n                        1\n                    ], dfrom = b.cmp(p.from, m.from), dto = b.cmp(p.to, m.to);\n                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n                    newParts.push({\n                        from: p.from,\n                        to: m.from\n                    });\n                if (dto > 0 || !mk.inclusiveRight && !dto)\n                    newParts.push({\n                        from: m.to,\n                        to: p.to\n                    });\n                parts.splice.apply(parts, newParts);\n                j += newParts.length - 3;\n            }\n        }\n        return parts;\n    }\n    function detachMarkedSpans(line) {\n        let spans = line.markedSpans;\n        if (!spans)\n            return;\n        for (let i = 0; i < spans.length; ++i)\n            spans[i].marker.detachLine(line);\n        line.markedSpans = null;\n    }\n    function attachMarkedSpans(line, spans) {\n        if (!spans)\n            return;\n        for (let i = 0; i < spans.length; ++i)\n            spans[i].marker.attachLine(line);\n        line.markedSpans = spans;\n    }\n    function extraLeft(marker) {\n        return marker.inclusiveLeft ? -1 : 0;\n    }\n    function extraRight(marker) {\n        return marker.inclusiveRight ? 1 : 0;\n    }\n    function compareCollapsedMarkers(a, b) {\n        let lenDiff = a.lines.length - b.lines.length;\n        if (lenDiff != 0)\n            return lenDiff;\n        let aPos = a.find(), bPos = b.find();\n        let fromCmp = b.cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n        if (fromCmp)\n            return -fromCmp;\n        let toCmp = b.cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n        if (toCmp)\n            return toCmp;\n        return b.id - a.id;\n    }\n    function collapsedSpanAtSide(line, start) {\n        let sps = c.sawCollapsedSpans && line.markedSpans, found;\n        if (sps)\n            for (let sp, i = 0; i < sps.length; ++i) {\n                sp = sps[i];\n                if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n                    found = sp.marker;\n            }\n        return found;\n    }\n    function collapsedSpanAtStart(line) {\n        return collapsedSpanAtSide(line, true);\n    }\n    function collapsedSpanAtEnd(line) {\n        return collapsedSpanAtSide(line, false);\n    }\n    function collapsedSpanAround(line, ch) {\n        let sps = c.sawCollapsedSpans && line.markedSpans, found;\n        if (sps)\n            for (let i = 0; i < sps.length; ++i) {\n                let sp = sps[i];\n                if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n                    found = sp.marker;\n            }\n        return found;\n    }\n    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n        let line = d.getLine(doc, d.lineNo);\n        let sps = c.sawCollapsedSpans && line.markedSpans;\n        if (sps)\n            for (let i = 0; i < sps.length; ++i) {\n                let sp = sps[i];\n                if (!sp.marker.collapsed)\n                    continue;\n                let found = sp.marker.find(0);\n                let fromCmp = b.cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n                let toCmp = b.cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n                if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)\n                    continue;\n                if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? b.cmp(found.to, from) >= 0 : b.cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? b.cmp(found.from, to) <= 0 : b.cmp(found.from, to) < 0))\n                    return true;\n            }\n    }\n    function visualLine(line) {\n        let merged;\n        while (merged = collapsedSpanAtStart(line))\n            line = merged.find(-1, true).line;\n        return line;\n    }\n    function visualLineEnd(line) {\n        let merged;\n        while (merged = collapsedSpanAtEnd(line))\n            line = merged.find(1, true).line;\n        return line;\n    }\n    function visualLineContinued(line) {\n        let merged, lines;\n        while (merged = collapsedSpanAtEnd(line)) {\n            line = merged.find(1, true).line;\n            (lines || (lines = [])).push(line);\n        }\n        return lines;\n    }\n    function visualLineNo(doc, lineN) {\n        let line = d.getLine(doc, lineN), vis = visualLine(line);\n        if (line == vis)\n            return lineN;\n        return d.lineNo(vis);\n    }\n    function visualLineEndNo(doc, lineN) {\n        if (lineN > doc.lastLine())\n            return lineN;\n        let line = d.getLine(doc, lineN), merged;\n        if (!lineIsHidden(doc, line))\n            return lineN;\n        while (merged = collapsedSpanAtEnd(line))\n            line = merged.find(1, true).line;\n        return d.lineNo(line) + 1;\n    }\n    function lineIsHidden(doc, line) {\n        let sps = c.sawCollapsedSpans && line.markedSpans;\n        if (sps)\n            for (let sp, i = 0; i < sps.length; ++i) {\n                sp = sps[i];\n                if (!sp.marker.collapsed)\n                    continue;\n                if (sp.from == null)\n                    return true;\n                if (sp.marker.widgetNode)\n                    continue;\n                if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n                    return true;\n            }\n    }\n    function lineIsHiddenInner(doc, line, span) {\n        if (span.to == null) {\n            let end = span.marker.find(1, true);\n            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n        }\n        if (span.marker.inclusiveRight && span.to == line.text.length)\n            return true;\n        for (let sp, i = 0; i < line.markedSpans.length; ++i) {\n            sp = line.markedSpans[i];\n            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))\n                return true;\n        }\n    }\n    function heightAtLine(lineObj) {\n        lineObj = visualLine(lineObj);\n        let h = 0, chunk = lineObj.parent;\n        for (let i = 0; i < chunk.lines.length; ++i) {\n            let line = chunk.lines[i];\n            if (line == lineObj)\n                break;\n            else\n                h += line.height;\n        }\n        for (let p = chunk.parent; p; chunk = p, p = chunk.parent) {\n            for (let i = 0; i < p.children.length; ++i) {\n                let cur = p.children[i];\n                if (cur == chunk)\n                    break;\n                else\n                    h += cur.height;\n            }\n        }\n        return h;\n    }\n    function lineLength(line) {\n        if (line.height == 0)\n            return 0;\n        let len = line.text.length, merged, cur = line;\n        while (merged = collapsedSpanAtStart(cur)) {\n            let found = merged.find(0, true);\n            cur = found.from.line;\n            len += found.from.ch - found.to.ch;\n        }\n        cur = line;\n        while (merged = collapsedSpanAtEnd(cur)) {\n            let found = merged.find(0, true);\n            len -= cur.text.length - found.from.ch;\n            cur = found.to.line;\n            len += cur.text.length - found.to.ch;\n        }\n        return len;\n    }\n    function findMaxLine(cm) {\n        let d = cm.display, doc = cm.doc;\n        d.maxLine = d.getLine(doc, doc.first);\n        d.maxLineLength = lineLength(d.maxLine);\n        d.maxLineChanged = true;\n        doc.iter(line => {\n            let len = lineLength(line);\n            if (len > d.maxLineLength) {\n                d.maxLineLength = len;\n                d.maxLine = line;\n            }\n        });\n    }\n    return {\n        MarkedSpan: MarkedSpan,\n        getMarkedSpanFor: getMarkedSpanFor,\n        removeMarkedSpan: removeMarkedSpan,\n        addMarkedSpan: addMarkedSpan,\n        stretchSpansOverChange: stretchSpansOverChange,\n        removeReadOnlyRanges: removeReadOnlyRanges,\n        detachMarkedSpans: detachMarkedSpans,\n        attachMarkedSpans: attachMarkedSpans,\n        compareCollapsedMarkers: compareCollapsedMarkers,\n        collapsedSpanAtStart: collapsedSpanAtStart,\n        collapsedSpanAtEnd: collapsedSpanAtEnd,\n        collapsedSpanAround: collapsedSpanAround,\n        conflictingCollapsedRange: conflictingCollapsedRange,\n        visualLine: visualLine,\n        visualLineEnd: visualLineEnd,\n        visualLineContinued: visualLineContinued,\n        visualLineNo: visualLineNo,\n        visualLineEndNo: visualLineEndNo,\n        lineIsHidden: lineIsHidden,\n        heightAtLine: heightAtLine,\n        lineLength: lineLength,\n        findMaxLine: findMaxLine\n    };\n});"]}