{"version":3,"sources":["primitives/edit/methods.js"],"names":["define","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","m_highlight_worker","m_line_numbers","m_scrollbars","CodeMirror","optionHandlers","helpers","prototype","constructor","focus","window","this","display","input","setOption","option","value","options","old","hasOwnProperty","operation","signal","getOption","getDoc","doc","addKeyMap","map","bottom","state","keyMaps","getKeyMap","removeKeyMap","maps","length","name","splice","addOverlay","methodOp","spec","mode","token","getMode","startState","Error","insertSorted","overlays","modeSpec","opaque","priority","overlay","modeGen","regChange","removeOverlay","cur","indentLine","dir","aggressive","smartIndent","isLine","indentSelection","how","ranges","sel","end","range","empty","head","line","primIndex","ensureCursorVisible","from","to","start","Math","max","min","lastLine","ch","newRanges","replaceOneSelection","Range","sel_dontScroll","getTokenAt","pos","precise","takeToken","getLineTokens","Pos","getTokenTypeAt","clipPos","type","styles","getLineStyles","getLine","before","after","mid","cut","indexOf","slice","getModeAt","innerMode","getHelper","getHelpers","found","help","push","val","helperType","_global","pred","getStateAfter","clipLine","first","size","getContextBefore","cursorCoords","primary","charCoords","coordsChar","coords","fromCoordSystem","left","top","lineAtHeight","height","viewOffset","heightAtLine","includeWidgets","lineObj","last","intoCoordSystem","defaultTextHeight","textHeight","defaultCharWidth","charWidth","getViewport","viewFrom","viewTo","addWidget","node","scroll","vert","horiz","style","position","setAttribute","setUneditable","sizer","appendChild","vspace","wrapper","clientHeight","hspace","clientWidth","lineSpace","offsetHeight","offsetWidth","right","scrollIntoView","triggerOnKeyDown","onKeyDown","triggerOnKeyPress","onKeyPress","triggerOnKeyUp","onKeyUp","triggerOnMouseDown","onMouseDown","execCommand","cmd","commands","call","triggerElectric","text","findPosH","amount","unit","visually","hitSide","moveH","extendSelectionsBy","shift","extend","rtlMoveVisually","sel_move","deleteH","somethingSelected","replaceSelection","deleteNearSelection","other","findPosV","goalColumn","moveV","goals","collapse","headPos","addToScrollTop","findWordAt","helper","sticky","startChar","charAt","check","isWordChar","test","toggleOverwrite","overwrite","addClass","cursorDiv","rmClass","hasFocus","getField","activeElt","isReadOnly","readOnly","cantEdit","scrollTo","y","scrollToCoords","getScrollInfo","scroller","scrollLeft","scrollTop","scrollHeight","scrollGap","barHeight","width","scrollWidth","barWidth","displayHeight","displayWidth","margin","cursorScrollMargin","scrollToRange","scrollToCoordsRange","setSize","interpret","String","lineWrapping","clearLineMeasurementCache","lineNo","iter","widgets","noHScroll","regLineChange","curOp","forceUpdate","runInOp","startOperation","endOperation","refresh","oldHeight","cachedTextHeight","clearCaches","updateGutterSpace","abs","estimateLineHeights","swapDoc","cm","attachDoc","reset","forceScroll","signalLater","phrase","phraseText","phrases","Object","getInputField","getWrapperElement","getScrollerElement","getGutterElement","gutters","startWorker","time","maybeUpdateLineNumberWidth","measureForScrollbars","updateScrollbars","measure","eventMixin","registerHelper","registerGlobalHelper","predicate","oldPos","origDir","moveOnce","boundToLine","next","moveVisually","moveLogically","findNextLine","endOfLine","sawType","group","result","skipAtomic","equalCursorPos","target","pageSize","innerHeight","document","documentElement","moveAmount","outside"],"mappings":"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","file":"../../../primitives/edit/methods.js","sourcesContent":["define([\n    './deleteNearSelection',\n    './commands',\n    '../model/document_data',\n    '../util/dom',\n    '../util/event',\n    '../line/highlight',\n    '../input/indent',\n    '../input/input',\n    './key_events',\n    './mouse_events',\n    '../input/keymap',\n    '../input/movement',\n    '../display/operations',\n    '../line/pos',\n    '../measurement/position_measurement',\n    '../model/selection',\n    '../model/selection_updates',\n    '../display/scrolling',\n    '../line/spans',\n    '../display/update_display',\n    '../util/misc',\n    '../util/operation_group',\n    '../line/utils_line',\n    '../display/view_tracking',\n    '../display/highlight_worker',\n    '../display/line_numbers',\n    '../display/scrollbars'\n], function (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x,m_highlight_worker,m_line_numbers,m_scrollbars) {\n    'use strict';\n    return function (CodeMirror) {\n        let optionHandlers = CodeMirror.optionHandlers;\n        let helpers = CodeMirror.helpers = {};\n        CodeMirror.prototype = {\n            constructor: CodeMirror,\n            focus: function () {\n                window.focus();\n                this.display.input.focus();\n            },\n            setOption: function (option, value) {\n                let options = this.options, old = options[option];\n                if (options[option] == value && option != 'mode')\n                    return;\n                options[option] = value;\n                if (optionHandlers.hasOwnProperty(option))\n                    m.operation(this, optionHandlers[option])(this, value, old);\n                e.signal(this, 'optionChange', this, option);\n            },\n            getOption: function (option) {\n                return this.options[option];\n            },\n            getDoc: function () {\n                return this.doc;\n            },\n            addKeyMap: function (map, bottom) {\n                this.state.keyMaps[bottom ? 'push' : 'unshift'](k.getKeyMap(map));\n            },\n            removeKeyMap: function (map) {\n                let maps = this.state.keyMaps;\n                for (let i = 0; i < maps.length; ++i)\n                    if (maps[i] == map || maps[i].name == map) {\n                        maps.splice(i, 1);\n                        return true;\n                    }\n            },\n            addOverlay: m.methodOp(function (spec, options) {\n                let mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n                if (mode.startState)\n                    throw new Error('Overlays may not be stateful.');\n                u.insertSorted(this.state.overlays, {\n                    mode: mode,\n                    modeSpec: spec,\n                    opaque: options && options.opaque,\n                    priority: options && options.priority || 0\n                }, overlay => overlay.priority);\n                this.state.modeGen++;\n                x.regChange(this);\n            }),\n            removeOverlay: m.methodOp(function (spec) {\n                let overlays = this.state.overlays;\n                for (let i = 0; i < overlays.length; ++i) {\n                    let cur = overlays[i].modeSpec;\n                    if (cur == spec || typeof spec == 'string' && cur.name == spec) {\n                        overlays.splice(i, 1);\n                        this.state.modeGen++;\n                        x.regChange(this);\n                        return;\n                    }\n                }\n            }),\n            indentLine: m.methodOp(function (n, dir, aggressive) {\n                if (typeof dir != 'string' && typeof dir != 'number') {\n                    if (dir == null)\n                        dir = this.options.smartIndent ? 'smart' : 'prev';\n                    else\n                        dir = dir ? 'add' : 'subtract';\n                }\n                if (w.isLine(this.doc, n))\n                    g.indentLine(this, n, dir, aggressive);\n            }),\n            indentSelection: m.methodOp(function (how) {\n                let ranges = this.doc.sel.ranges, end = -1;\n                for (let i = 0; i < ranges.length; i++) {\n                    let range = ranges[i];\n                    if (!range.empty()) {\n                        let from = range.from(), to = range.to();\n                        let start = Math.max(end, from.line);\n                        end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n                        for (let j = start; j < end; ++j)\n                            g.indentLine(this, j, how);\n                        let newRanges = this.doc.sel.ranges;\n                        if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n                            q.replaceOneSelection(this.doc, i, new p.Range(from, newRanges[i].to()), u.sel_dontScroll);\n                    } else if (range.head.line > end) {\n                        g.indentLine(this, range.head.line, how, true);\n                        end = range.head.line;\n                        if (i == this.doc.sel.primIndex)\n                            r.ensureCursorVisible(this);\n                    }\n                }\n            }),\n            getTokenAt: function (pos, precise) {\n                return f.takeToken(this, pos, precise);\n            },\n            getLineTokens: function (line, precise) {\n                return f.takeToken(this, n.Pos(line), precise, true);\n            },\n            getTokenTypeAt: function (pos) {\n                pos = n.clipPos(this.doc, pos);\n                let styles = f.getLineStyles(this, w.getLine(this.doc, pos.line));\n                let before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n                let type;\n                if (ch == 0)\n                    type = styles[2];\n                else\n                    for (;;) {\n                        let mid = before + after >> 1;\n                        if ((mid ? styles[mid * 2 - 1] : 0) >= ch)\n                            after = mid;\n                        else if (styles[mid * 2 + 1] < ch)\n                            before = mid + 1;\n                        else {\n                            type = styles[mid * 2 + 2];\n                            break;\n                        }\n                    }\n                let cut = type ? type.indexOf('overlay ') : -1;\n                return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n            },\n            getModeAt: function (pos) {\n                let mode = this.doc.mode;\n                if (!mode.innerMode)\n                    return mode;\n                return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n            },\n            getHelper: function (pos, type) {\n                return this.getHelpers(pos, type)[0];\n            },\n            getHelpers: function (pos, type) {\n                let found = [];\n                if (!helpers.hasOwnProperty(type))\n                    return found;\n                let help = helpers[type], mode = this.getModeAt(pos);\n                if (typeof mode[type] == 'string') {\n                    if (help[mode[type]])\n                        found.push(help[mode[type]]);\n                } else if (mode[type]) {\n                    for (let i = 0; i < mode[type].length; i++) {\n                        let val = help[mode[type][i]];\n                        if (val)\n                            found.push(val);\n                    }\n                } else if (mode.helperType && help[mode.helperType]) {\n                    found.push(help[mode.helperType]);\n                } else if (help[mode.name]) {\n                    found.push(help[mode.name]);\n                }\n                for (let i = 0; i < help._global.length; i++) {\n                    let cur = help._global[i];\n                    if (cur.pred(mode, this) && u.indexOf(found, cur.val) == -1)\n                        found.push(cur.val);\n                }\n                return found;\n            },\n            getStateAfter: function (line, precise) {\n                let doc = this.doc;\n                line = n.clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n                return f.getContextBefore(this, line + 1, precise).state;\n            },\n            cursorCoords: function (start, mode) {\n                let pos, range = this.doc.sel.primary();\n                if (start == null)\n                    pos = range.head;\n                else if (typeof start == 'object')\n                    pos = n.clipPos(this.doc, start);\n                else\n                    pos = start ? range.from() : range.to();\n                return o.cursorCoords(this, pos, mode || 'page');\n            },\n            charCoords: function (pos, mode) {\n                return o.charCoords(this, n.clipPos(this.doc, pos), mode || 'page');\n            },\n            coordsChar: function (coords, mode) {\n                coords = o.fromCoordSystem(this, coords, mode || 'page');\n                return o.coordsChar(this, coords.left, coords.top);\n            },\n            lineAtHeight: function (height, mode) {\n                height = o.fromCoordSystem(this, {\n                    top: height,\n                    left: 0\n                }, mode || 'page').top;\n                return w.lineAtHeight(this.doc, height + this.display.viewOffset);\n            },\n            heightAtLine: function (line, mode, includeWidgets) {\n                let end = false, lineObj;\n                if (typeof line == 'number') {\n                    let last = this.doc.first + this.doc.size - 1;\n                    if (line < this.doc.first)\n                        line = this.doc.first;\n                    else if (line > last) {\n                        line = last;\n                        end = true;\n                    }\n                    lineObj = w.getLine(this.doc, line);\n                } else {\n                    lineObj = line;\n                }\n                return o.intoCoordSystem(this, lineObj, {\n                    top: 0,\n                    left: 0\n                }, mode || 'page', includeWidgets || end).top + (end ? this.doc.height - s.heightAtLine(lineObj) : 0);\n            },\n            defaultTextHeight: function () {\n                return o.textHeight(this.display);\n            },\n            defaultCharWidth: function () {\n                return o.charWidth(this.display);\n            },\n            getViewport: function () {\n                return {\n                    from: this.display.viewFrom,\n                    to: this.display.viewTo\n                };\n            },\n            addWidget: function (pos, node, scroll, vert, horiz) {\n                let display = this.display;\n                pos = o.cursorCoords(this, n.clipPos(this.doc, pos));\n                let top = pos.bottom, left = pos.left;\n                node.style.position = 'absolute';\n                node.setAttribute('cm-ignore-events', 'true');\n                this.display.input.setUneditable(node);\n                display.sizer.appendChild(node);\n                if (vert == 'over') {\n                    top = pos.top;\n                } else if (vert == 'above' || vert == 'near') {\n                    let vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n                    if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n                        top = pos.top - node.offsetHeight;\n                    else if (pos.bottom + node.offsetHeight <= vspace)\n                        top = pos.bottom;\n                    if (left + node.offsetWidth > hspace)\n                        left = hspace - node.offsetWidth;\n                }\n                node.style.top = top + 'px';\n                node.style.left = node.style.right = '';\n                if (horiz == 'right') {\n                    left = display.sizer.clientWidth - node.offsetWidth;\n                    node.style.right = '0px';\n                } else {\n                    if (horiz == 'left')\n                        left = 0;\n                    else if (horiz == 'middle')\n                        left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n                    node.style.left = left + 'px';\n                }\n                if (scroll)\n                    r.scrollIntoView(this, {\n                        left,\n                        top,\n                        right: left + node.offsetWidth,\n                        bottom: top + node.offsetHeight\n                    });\n            },\n            triggerOnKeyDown: m.methodOp(i.onKeyDown),\n            triggerOnKeyPress: m.methodOp(i.onKeyPress),\n            triggerOnKeyUp: i.onKeyUp,\n            triggerOnMouseDown: m.methodOp(j.onMouseDown),\n            execCommand: function (cmd) {\n                if (b.commands.hasOwnProperty(cmd))\n                    return b.commands[cmd].call(null, this);\n            },\n            triggerElectric: m.methodOp(function (text) {\n                h.triggerElectric(this, text);\n            }),\n            findPosH: function (from, amount, unit, visually) {\n                let dir = 1;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                let cur = n.clipPos(this.doc, from);\n                for (let i = 0; i < amount; ++i) {\n                    cur = findPosH(this.doc, cur, dir, unit, visually);\n                    if (cur.hitSide)\n                        break;\n                }\n                return cur;\n            },\n            moveH: m.methodOp(function (dir, unit) {\n                this.extendSelectionsBy(range => {\n                    if (this.display.shift || this.doc.extend || range.empty())\n                        return findPosH(this.doc, range.head, dir, unit, this.options.rtlMoveVisually);\n                    else\n                        return dir < 0 ? range.from() : range.to();\n                }, u.sel_move);\n            }),\n            deleteH: m.methodOp(function (dir, unit) {\n                let sel = this.doc.sel, doc = this.doc;\n                if (sel.somethingSelected())\n                    doc.replaceSelection('', null, '+delete');\n                else\n                    a.deleteNearSelection(this, range => {\n                        let other = findPosH(doc, range.head, dir, unit, false);\n                        return dir < 0 ? {\n                            from: other,\n                            to: range.head\n                        } : {\n                            from: range.head,\n                            to: other\n                        };\n                    });\n            }),\n            findPosV: function (from, amount, unit, goalColumn) {\n                let dir = 1, x = goalColumn;\n                if (amount < 0) {\n                    dir = -1;\n                    amount = -amount;\n                }\n                let cur = n.clipPos(this.doc, from);\n                for (let i = 0; i < amount; ++i) {\n                    let coords = o.cursorCoords(this, cur, 'div');\n                    if (x == null)\n                        x = coords.left;\n                    else\n                        coords.left = x;\n                    cur = findPosV(this, coords, dir, unit);\n                    if (cur.hitSide)\n                        break;\n                }\n                return cur;\n            },\n            moveV: m.methodOp(function (dir, unit) {\n                let doc = this.doc, goals = [];\n                let collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n                doc.extendSelectionsBy(range => {\n                    if (collapse)\n                        return dir < 0 ? range.from() : range.to();\n                    let headPos = o.cursorCoords(this, range.head, 'div');\n                    if (range.goalColumn != null)\n                        headPos.left = range.goalColumn;\n                    goals.push(headPos.left);\n                    let pos = findPosV(this, headPos, dir, unit);\n                    if (unit == 'page' && range == doc.sel.primary())\n                        r.addToScrollTop(this, o.charCoords(this, pos, 'div').top - headPos.top);\n                    return pos;\n                }, u.sel_move);\n                if (goals.length)\n                    for (let i = 0; i < doc.sel.ranges.length; i++)\n                        doc.sel.ranges[i].goalColumn = goals[i];\n            }),\n            findWordAt: function (pos) {\n                let doc = this.doc, line = w.getLine(doc, pos.line).text;\n                let start = pos.ch, end = pos.ch;\n                if (line) {\n                    let helper = this.getHelper(pos, 'wordChars');\n                    if ((pos.sticky == 'before' || end == line.length) && start)\n                        --start;\n                    else\n                        ++end;\n                    let startChar = line.charAt(start);\n                    let check = u.isWordChar(startChar, helper) ? ch => u.isWordChar(ch, helper) : /\\s/.test(startChar) ? ch => /\\s/.test(ch) : ch => !/\\s/.test(ch) && !u.isWordChar(ch);\n                    while (start > 0 && check(line.charAt(start - 1)))\n                        --start;\n                    while (end < line.length && check(line.charAt(end)))\n                        ++end;\n                }\n                return new p.Range(n.Pos(pos.line, start), n.Pos(pos.line, end));\n            },\n            toggleOverwrite: function (value) {\n                if (value != null && value == this.state.overwrite)\n                    return;\n                if (this.state.overwrite = !this.state.overwrite)\n                    d.addClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                else\n                    d.rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');\n                e.signal(this, 'overwriteToggle', this, this.state.overwrite);\n            },\n            hasFocus: function () {\n                return this.display.input.getField() == d.activeElt();\n            },\n            isReadOnly: function () {\n                return !!(this.options.readOnly || this.doc.cantEdit);\n            },\n            scrollTo: m.methodOp(function (x, y) {\n                r.scrollToCoords(this, x, y);\n            }),\n            getScrollInfo: function () {\n                let scroller = this.display.scroller;\n                return {\n                    left: scroller.scrollLeft,\n                    top: scroller.scrollTop,\n                    height: scroller.scrollHeight - o.scrollGap(this) - this.display.barHeight,\n                    width: scroller.scrollWidth - o.scrollGap(this) - this.display.barWidth,\n                    clientHeight: o.displayHeight(this),\n                    clientWidth: o.displayWidth(this)\n                };\n            },\n            scrollIntoView: m.methodOp(function (range, margin) {\n                if (range == null) {\n                    range = {\n                        from: this.doc.sel.primary().head,\n                        to: null\n                    };\n                    if (margin == null)\n                        margin = this.options.cursorScrollMargin;\n                } else if (typeof range == 'number') {\n                    range = {\n                        from: n.Pos(range, 0),\n                        to: null\n                    };\n                } else if (range.from == null) {\n                    range = {\n                        from: range,\n                        to: null\n                    };\n                }\n                if (!range.to)\n                    range.to = range.from;\n                range.margin = margin || 0;\n                if (range.from.line != null) {\n                    r.scrollToRange(this, range);\n                } else {\n                    r.scrollToCoordsRange(this, range.from, range.to, range.margin);\n                }\n            }),\n            setSize: m.methodOp(function (width, height) {\n                let interpret = val => typeof val == 'number' || /^\\d+$/.test(String(val)) ? val + 'px' : val;\n                if (width != null)\n                    this.display.wrapper.style.width = interpret(width);\n                if (height != null)\n                    this.display.wrapper.style.height = interpret(height);\n                if (this.options.lineWrapping)\n                    o.clearLineMeasurementCache(this);\n                let lineNo = this.display.viewFrom;\n                this.doc.iter(lineNo, this.display.viewTo, line => {\n                    if (line.widgets)\n                        for (let i = 0; i < line.widgets.length; i++)\n                            if (line.widgets[i].noHScroll) {\n                                x.regLineChange(this, lineNo, 'widget');\n                                break;\n                            }\n                    ++lineNo;\n                });\n                this.curOp.forceUpdate = true;\n                e.signal(this, 'refresh', this);\n            }),\n            operation: function (f) {\n                return m.runInOp(this, f);\n            },\n            startOperation: function () {\n                return m.startOperation(this);\n            },\n            endOperation: function () {\n                return m.endOperation(this);\n            },\n            refresh: m.methodOp(function () {\n                let oldHeight = this.display.cachedTextHeight;\n                x.regChange(this);\n                this.curOp.forceUpdate = true;\n                o.clearCaches(this);\n                r.scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n                t.updateGutterSpace(this);\n                if (oldHeight == null || Math.abs(oldHeight - o.textHeight(this.display)) > 0.5)\n                    o.estimateLineHeights(this);\n                e.signal(this, 'refresh', this);\n            }),\n            swapDoc: m.methodOp(function (doc) {\n                let old = this.doc;\n                old.cm = null;\n                c.attachDoc(this, doc);\n                o.clearCaches(this);\n                this.display.input.reset();\n                r.scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n                this.curOp.forceScroll = true;\n                v.signalLater(this, 'swapDoc', this, old);\n                return old;\n            }),\n            phrase: function (phraseText) {\n                let phrases = this.options.phrases;\n                return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n            },\n            getInputField: function () {\n                return this.display.input.getField();\n            },\n            getWrapperElement: function () {\n                return this.display.wrapper;\n            },\n            getScrollerElement: function () {\n                return this.display.scroller;\n            },\n            getGutterElement: function () {\n                return this.display.gutters;\n            },\n\n            startWorker : function(time) {\n                return m_highlight_worker.startWorker(this,time);\n            },\n\n            maybeUpdateLineNumberWidth : function() {\n                return m_line_numbers.maybeUpdateLineNumberWidth(this);\n            },\n\n            measureForScrollbars : function() {\n                return m_scrollbars.measureForScrollbars(this);\n            },\n\n            updateScrollbars : function(measure) {\n                return m_scrollbars.updateScrollbars(this,measure);\n            }\n        };\n        e.eventMixin(CodeMirror);\n        CodeMirror.registerHelper = function (type, name, value) {\n            if (!helpers.hasOwnProperty(type))\n                helpers[type] = CodeMirror[type] = { _global: [] };\n            helpers[type][name] = value;\n        };\n        CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {\n            CodeMirror.registerHelper(type, name, value);\n            helpers[type]._global.push({\n                pred: predicate,\n                val: value\n            });\n        };\n    };\n    function findPosH(doc, pos, dir, unit, visually) {\n        let oldPos = pos;\n        let origDir = dir;\n        let lineObj = w.getLine(doc, pos.line);\n        function findNextLine() {\n            let l = pos.line + dir;\n            if (l < doc.first || l >= doc.first + doc.size)\n                return false;\n            pos = new n.Pos(l, pos.ch, pos.sticky);\n            return lineObj = w.getLine(doc, l);\n        }\n        function moveOnce(boundToLine) {\n            let next;\n            if (visually) {\n                next = l.moveVisually(doc.cm, lineObj, pos, dir);\n            } else {\n                next = l.moveLogically(lineObj, pos, dir);\n            }\n            if (next == null) {\n                if (!boundToLine && findNextLine())\n                    pos = l.endOfLine(visually, doc.cm, lineObj, pos.line, dir);\n                else\n                    return false;\n            } else {\n                pos = next;\n            }\n            return true;\n        }\n        if (unit == 'char') {\n            moveOnce();\n        } else if (unit == 'column') {\n            moveOnce(true);\n        } else if (unit == 'word' || unit == 'group') {\n            let sawType = null, group = unit == 'group';\n            let helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');\n            for (let first = true;; first = false) {\n                if (dir < 0 && !moveOnce(!first))\n                    break;\n                let cur = lineObj.text.charAt(pos.ch) || '\\n';\n                let type = u.isWordChar(cur, helper) ? 'w' : group && cur == '\\n' ? 'n' : !group || /\\s/.test(cur) ? null : 'p';\n                if (group && !first && !type)\n                    type = 's';\n                if (sawType && sawType != type) {\n                    if (dir < 0) {\n                        dir = 1;\n                        moveOnce();\n                        pos.sticky = 'after';\n                    }\n                    break;\n                }\n                if (type)\n                    sawType = type;\n                if (dir > 0 && !moveOnce(!first))\n                    break;\n            }\n        }\n        let result = q.skipAtomic(doc, pos, oldPos, origDir, true);\n        if (n.equalCursorPos(oldPos, result))\n            result.hitSide = true;\n        return result;\n    }\n    function findPosV(cm, pos, dir, unit) {\n        let doc = cm.doc, x = pos.left, y;\n        if (unit == 'page') {\n            let pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n            let moveAmount = Math.max(pageSize - 0.5 * o.textHeight(cm.display), 3);\n            y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n        } else if (unit == 'line') {\n            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n        }\n        let target;\n        for (;;) {\n            target = o.coordsChar(cm, x, y);\n            if (!target.outside)\n                break;\n            if (dir < 0 ? y <= 0 : y >= doc.height) {\n                target.hitSide = true;\n                break;\n            }\n            y += dir * 5;\n        }\n        return target;\n    }\n});"]}